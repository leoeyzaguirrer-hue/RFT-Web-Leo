<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>TRAP â†’ TRAC | ActivaciÃ³n Conductual</title>
  <meta name="description" content="Aprende a reconocer las trampas de la depresiÃ³n y construir salidas efectivas con el modelo TRAP-TRAC de ActivaciÃ³n Conductual.">
  <meta name="theme-color" content="#D0E8F7">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸª¤</text></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; overflow-x: hidden; }
    #root { min-height: 100vh; }
  </style>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;


// ==================== DATA ====================
const LEVELS_META = [
  { id: 1, title: "Reconoce la Trampa", emoji: "ğŸª¤", color: "#E74C3C", desc: "Identifica los componentes del ciclo TRAP" },
  { id: 2, title: "Distingue el Camino", emoji: "ğŸ”", color: "#1A9B78", desc: "Diferencia TRAP de TRAC y detecta evitaciÃ³n encubierta" },
  { id: 3, title: "Construye la Salida", emoji: "ğŸ”§", color: "#D4880F", desc: "Genera afrontamientos alternativos efectivos" },
  { id: 4, title: "Consulta Simulada", emoji: "ğŸ¯", color: "#8E44AD", desc: "Aplica todo en un caso clÃ­nico interactivo" },
];

// ====== LEVEL 1 CONTENT ======
const L1_THEORY = [
  {
    title: "Â¿Por quÃ© estÃ¡s aquÃ­? ğŸ¤”",
    content: `Cuando una persona estÃ¡ deprimida, su primer instinto es **retirarse**: quedarse en cama, cancelar planes, evitar llamadas. Esto es completamente comprensible.\n\nPero aquÃ­ estÃ¡ el problema: **esa retirada mantiene la depresiÃ³n**. No la causa, pero la alimenta.\n\nLa ActivaciÃ³n Conductual nos dice algo poderoso: **no necesitas sentirte mejor para empezar a actuar**. Puedes actuar primero, y el estado de Ã¡nimo cambia despuÃ©s.\n\nPero para salir del ciclo, primero necesitas **ver la trampa**. Eso es exactamente lo que vas a aprender aquÃ­.`,
  },
  {
    title: "El Modelo TRAP ğŸª¤",
    content: `TRAP significa **trampa** en inglÃ©s, y es un acrÃ³nimo perfecto porque describe cÃ³mo quedamos atrapados:\n\n**T â€” Trigger (Desencadenante)** ğŸ’¥\nUn evento o situaciÃ³n que inicia todo. Puede ser externo (una pelea, perder el trabajo) o interno (un pensamiento, un recuerdo).\n\n**R â€” Response (Respuesta emocional)** ğŸ˜”\nCÃ³mo te sientes ante ese desencadenante: tristeza, ansiedad, vacÃ­o, irritabilidad, fatiga.\n\n**AP â€” Avoidance Pattern (PatrÃ³n de EvitaciÃ³n)** ğŸ”„\nLo que HACES para lidiar con esa emociÃ³n: quedarte en cama, cancelar planes, aislarte, scrollear redes sin parar, "maratÃ³n" de series.\n\nEl truco cruel es que la evitaciÃ³n **funciona a corto plazo** (sientes alivio), pero **a largo plazo te aleja de las fuentes de bienestar** y la depresiÃ³n se mantiene o empeora.`,
  },
  {
    title: "Â¿Por quÃ© la evitaciÃ³n es una trampa? âš ï¸",
    content: `Imagina esto:\n\nTu amigo te invita a salir â†’ Te sientes sin energÃ­a â†’ Cancelas y te quedas en cama.\n\nÂ¿QuÃ© pasa?\nâœ… **Alivio inmediato** â€” ya no tienes que esforzarte\nâŒ **Pierdes** contacto social, actividad, la posibilidad de disfrutar\nâŒ **Confirmas** la idea de que "no puedes"\nâŒ **MaÃ±ana** es aÃºn mÃ¡s difÃ­cil aceptar una invitaciÃ³n\n\nEsto es un **ciclo que se retroalimenta**: menos actividad â†’ menos reforzadores â†’ mÃ¡s depresiÃ³n â†’ menos actividad.\n\nLa evitaciÃ³n es lÃ³gica, es comprensible... pero es una trampa. Y el primer paso para salir es **reconocerla**.`,
  },
];

const L1_EXERCISES = [
  {
    type: "identify_component",
    instruction: "Lee el escenario y selecciona quÃ© componente del TRAP representa cada elemento seÃ±alado.",
    scenario: `MarÃ­a recibe un mensaje de su jefa pidiÃ©ndole una reuniÃ³n urgente ğŸ“±. Inmediatamente siente un nudo en el estÃ³mago y piensa "seguro me van a despedir" ğŸ˜°. En vez de responder, silencia el telÃ©fono y se acuesta a ver TikTok durante 3 horas ğŸ“µ.`,
    questions: [
      {
        text: "\"Recibe un mensaje de su jefa pidiÃ©ndole una reuniÃ³n urgente\" es...",
        options: ["Trigger (Desencadenante)", "Response (Respuesta)", "Avoidance Pattern (EvitaciÃ³n)"],
        correct: 0,
        feedback: {
          correct: "Â¡Exacto! ğŸ¯ El mensaje de la jefa es el evento externo que desencadena todo. Es la situaciÃ³n antecedente.",
          wrong: "No del todo. Este es el **Trigger** (Desencadenante): es el evento externo que inicia la cadena. No es lo que siente ni lo que hace, sino lo que PASA."
        }
      },
      {
        text: "\"Siente un nudo en el estÃ³mago y piensa 'seguro me van a despedir'\" es...",
        options: ["Trigger (Desencadenante)", "Response (Respuesta)", "Avoidance Pattern (EvitaciÃ³n)"],
        correct: 1,
        feedback: {
          correct: "Â¡Bien! ğŸ¯ El nudo en el estÃ³mago y el pensamiento catastrÃ³fico son la respuesta emocional/cognitiva al desencadenante.",
          wrong: "Esto es la **Response** (Respuesta): es cÃ³mo reacciona emocionalmente MarÃ­a al trigger. Incluye tanto sensaciones fÃ­sicas como pensamientos asociados al malestar."
        }
      },
      {
        text: "\"Silencia el telÃ©fono y se acuesta a ver TikTok durante 3 horas\" es...",
        options: ["Trigger (Desencadenante)", "Response (Respuesta)", "Avoidance Pattern (EvitaciÃ³n)"],
        correct: 2,
        feedback: {
          correct: "Â¡Perfecto! ğŸ¯ Silenciar el telÃ©fono y refugiarse en TikTok es el patrÃ³n de evitaciÃ³n: la conducta que alivia a corto plazo pero mantiene el problema.",
          wrong: "Esto es el **Avoidance Pattern** (PatrÃ³n de EvitaciÃ³n): es la CONDUCTA que MarÃ­a hace para escapar del malestar. Funciona a corto plazo (alivio) pero no resuelve nada."
        }
      },
    ],
  },
  {
    type: "identify_component",
    instruction: "Identifica cada componente del TRAP en este nuevo escenario.",
    scenario: `Carlos ve que sus compaÃ±eros de universidad subieron fotos de una fiesta a la que no lo invitaron ğŸ“¸. Se siente rechazado y con ganas de llorar ğŸ’”. Decide dejar de seguirlos en redes y no ir a clases la prÃ³xima semana ğŸš«.`,
    questions: [
      {
        text: "\"Ve fotos de una fiesta a la que no lo invitaron\" es...",
        options: ["Trigger (Desencadenante)", "Response (Respuesta)", "Avoidance Pattern (EvitaciÃ³n)"],
        correct: 0,
        feedback: {
          correct: "Â¡Correcto! ğŸ¯ Ver las fotos es el desencadenante: el evento que activa la cadena emocional.",
          wrong: "Este es el **Trigger**: el evento (ver las fotos) que pone en marcha la respuesta emocional. No es la emociÃ³n ni la conducta de escape."
        }
      },
      {
        text: "\"Se siente rechazado y con ganas de llorar\" es...",
        options: ["Trigger (Desencadenante)", "Response (Respuesta)", "Avoidance Pattern (EvitaciÃ³n)"],
        correct: 1,
        feedback: {
          correct: "Â¡SÃ­! ğŸ¯ El sentimiento de rechazo es la respuesta emocional ante lo que vio.",
          wrong: "Esto es la **Response**: el dolor emocional que aparece ante el desencadenante. Sentirse rechazado es la reacciÃ³n natural."
        }
      },
      {
        text: "\"Deja de seguirlos y no va a clases\" es...",
        options: ["Trigger (Desencadenante)", "Response (Respuesta)", "Avoidance Pattern (EvitaciÃ³n)"],
        correct: 2,
        feedback: {
          correct: "Â¡Exacto! ğŸ¯ Dejar de seguirlos y faltar a clases es la evitaciÃ³n: reduce el dolor a corto plazo pero lo aÃ­sla mÃ¡s.",
          wrong: "Esto es el **Avoidance Pattern**: la acciÃ³n de escape. Dejar de seguirlos y faltar a clases reduce el contacto con lo que duele, pero tambiÃ©n con lo que podrÃ­a ayudar."
        }
      },
    ],
  },
  {
    type: "classify_full",
    instruction: "Para cada escenario, arrastra los elementos a su categorÃ­a correcta del TRAP.",
    scenario: "Clasifica cada frase en la categorÃ­a que corresponde del modelo TRAP:",
    items: [
      { text: "Tu pareja te dice que necesitan hablar ğŸ“", correct: "T", emoji: "ğŸ’¥" },
      { text: "Sientes pÃ¡nico y el corazÃ³n se acelera ğŸ’“", correct: "R", emoji: "ğŸ˜°" },
      { text: "Le dices que estÃ¡s ocupado/a y evitas la conversaciÃ³n ğŸƒ", correct: "AP", emoji: "ğŸ”„" },
      { text: "Recibes una factura inesperada de $500 ğŸ’¸", correct: "T", emoji: "ğŸ’¥" },
      { text: "Te sientes abrumado/a y sin esperanza ğŸ˜©", correct: "R", emoji: "ğŸ˜°" },
      { text: "La guardas en un cajÃ³n sin abrirla y ves Netflix ğŸ“º", correct: "AP", emoji: "ğŸ”„" },
    ],
  },
  {
    type: "expert_trap",
    instruction: "âš¡ TRAMPA DEL EXPERTO âš¡\nCuidado: la respuesta obvia NO siempre es la correcta. Piensa funcionalmente.",
    scenario: `DespuÃ©s de una discusiÃ³n fuerte con su hermano, LucÃ­a se siente muy triste. Decide ir al gimnasio y hacer ejercicio intenso durante 2 horas, pensando: "Necesito sacarme esto de encima y no pensar en eso".`,
    question: "El ejercicio intenso de LucÃ­a en este contexto es...",
    options: [
      { text: "Afrontamiento saludable â€” estÃ¡ haciendo ejercicio, eso siempre es bueno", isCorrect: false },
      { text: "PatrÃ³n de evitaciÃ³n â€” estÃ¡ usando el ejercicio para escapar de la emociÃ³n y evitar abordar el conflicto", isCorrect: true },
      { text: "Ni lo uno ni lo otro â€” es simplemente una actividad neutral", isCorrect: false },
    ],
    feedback: {
      correct: "Â¡EXCELENTE! ğŸ† Esta es la clave del anÃ¡lisis funcional: no importa QUÃ‰ haces, importa PARA QUÃ‰ lo haces. El ejercicio es generalmente saludable, pero si su FUNCIÃ“N es escapar de una emociÃ³n y evitar resolver el conflicto con su hermano, entonces estÃ¡ funcionando como patrÃ³n de evitaciÃ³n. La misma conducta puede ser afrontamiento o evitaciÃ³n dependiendo de su funciÃ³n en el contexto.",
      wrong: "ğŸª¤ Â¡CaÃ­ste en la trampa del experto! La clave es: **no importa QUÃ‰ haces, importa PARA QUÃ‰ lo haces**. LucÃ­a dice explÃ­citamente \"no pensar en eso\" â€” el ejercicio aquÃ­ funciona como escape de la emociÃ³n y evitaciÃ³n del conflicto con su hermano. La misma conducta (hacer ejercicio) puede ser afrontamiento O evitaciÃ³n segÃºn su FUNCIÃ“N en ese contexto."
    },
  },
];

// ====== LEVEL 2 CONTENT ======
const L2_THEORY = [
  {
    title: "De TRAP a TRAC: La salida existe ğŸšª",
    content: `Ahora que puedes reconocer la trampa, es momento de conocer la salida.\n\nTRAC comparte dos componentes con TRAP:\n\n**T â€” Trigger (Desencadenante)** ğŸ’¥ â€” El mismo evento\n**R â€” Response (Respuesta)** ğŸ˜” â€” La misma emociÃ³n\n\nPero el tercer componente cambia todo:\n\n**AC â€” Alternative Coping (Afrontamiento Alternativo)** ğŸ’ª\n\nEn vez de evitar, la persona **hace algo diferente**: algo que la acerca a sus valores, que rompe el patrÃ³n, que la pone en contacto con fuentes de bienestar.\n\nâš ï¸ **Importante**: NO se trata de "sentirte bien primero". Se trata de actuar segÃºn un plan o valor, no segÃºn el estado de Ã¡nimo. La emociÃ³n cambia DESPUÃ‰S.`,
  },
  {
    title: "Â¡Cuidado con la evitaciÃ³n disfrazada! ğŸ­",
    content: `AquÃ­ viene lo difÃ­cil: no toda acciÃ³n es afrontamiento real. A veces hacemos cosas que PARECEN activas pero en el fondo son evitaciÃ³n.\n\n**SeÃ±ales de evitaciÃ³n disfrazada:**\n\nğŸ­ "Necesito pensar mÃ¡s antes de actuar" â€” cuando ya llevas semanas "pensando" (rumiaciÃ³n)\nğŸ­ "Voy a esperar a sentirme mejor" â€” posponer condicionado al estado de Ã¡nimo\nğŸ­ "Investigo mucho sobre depresiÃ³n" â€” leer sobre el problema para no HACER nada al respecto\nğŸ­ "Hago ejercicio para no pensar" â€” actividad como escape, no como acercamiento\nğŸ­ "Le mandÃ© un mensaje en vez de llamar" â€” acciÃ³n mÃ­nima que evita lo que realmente importa\n\n**La pregunta clave siempre es:**\n"Â¿Esta conducta me ACERCA a lo que valoro o me ALEJA del malestar?"\n\nSi solo te aleja del malestar â†’ probablemente es evitaciÃ³n.\nSi te acerca a lo que importa â†’ es afrontamiento.`,
  },
  {
    title: "Â¿CÃ³mo saber si es TRAP o TRAC? ğŸ§­",
    content: `Para distinguirlos, hazte estas preguntas sobre la conducta final:\n\n**1. Â¿CuÃ¡l es su funciÃ³n?**\nâ†’ Â¿Escapar/evitar? = TRAP\nâ†’ Â¿Acercarse/resolver? = TRAC\n\n**2. Â¿QuÃ© pasa despuÃ©s?**\nâ†’ Â¿Alivio momentÃ¡neo pero nada cambia? = TRAP\nâ†’ Â¿QuizÃ¡s incomodidad pero avance real? = TRAC\n\n**3. Â¿EstÃ¡ alineada con sus valores?**\nâ†’ Â¿Va en contra de lo que le importa? = TRAP\nâ†’ Â¿Es coherente con lo que valora? = TRAC\n\n**4. Â¿Rompe el patrÃ³n o lo mantiene?**\nâ†’ Â¿Es lo mismo de siempre? = TRAP\nâ†’ Â¿Es algo diferente a lo habitual? = TRAC\n\nRecuerda: **la misma conducta puede ser TRAP o TRAC segÃºn el contexto y la funciÃ³n**. No juzgamos la forma, analizamos la funciÃ³n.`,
  },
];

const L2_EXERCISES = [
  {
    type: "trap_or_trac",
    instruction: "Lee cada escenario completo y decide: Â¿es TRAP o TRAC?",
    scenarios: [
      {
        text: `Pedro se siente ansioso por una presentaciÃ³n de trabajo ğŸ˜°. Decide preparar sus diapositivas esa noche aunque no tiene ganas, porque sabe que su carrera es importante para Ã©l ğŸ’¼.`,
        correct: "TRAC",
        feedback: {
          correct: "Â¡SÃ­! ğŸ¯ Pedro actÃºa segÃºn sus valores (carrera) a pesar de la ansiedad. No espera a sentirse mejor: actÃºa desde un plan. Eso es TRAC.",
          wrong: "Este es TRAC: Pedro siente ansiedad pero actÃºa segÃºn sus valores (su carrera importa). No espera a sentirse bien; actÃºa segÃºn un plan, no segÃºn su estado de Ã¡nimo."
        }
      },
      {
        text: `Ana se siente culpable por no visitar a su mamÃ¡ ğŸ˜Ÿ. "Le mando un WhatsApp y ya", piensa, y le envÃ­a un emoji de corazÃ³n. Luego se distrae con redes sociales ğŸ“±.`,
        correct: "TRAP",
        feedback: {
          correct: "Â¡Exacto! ğŸ¯ El mensaje mÃ­nimo funciona como evitaciÃ³n disfrazada. Ana hace lo MÃNIMO para aliviar la culpa sin realmente acercarse a lo que valora (la relaciÃ³n con su mamÃ¡).",
          wrong: "Esto es TRAP: aunque Ana 'hace algo' (enviar emoji), su funciÃ³n es aliviar la culpa, no conectar con su mamÃ¡. Es acciÃ³n mÃ­nima que evita lo importante. El emoji NO equivale a una visita o llamada real."
        }
      },
      {
        text: `Diego se entera de que no lo seleccionaron para un ascenso ğŸ˜. Se siente decepcionado pero agenda una reuniÃ³n con su jefe para entender quÃ© puede mejorar ğŸ“‹.`,
        correct: "TRAC",
        feedback: {
          correct: "Â¡Muy bien! ğŸ¯ Diego siente la decepciÃ³n pero actÃºa hacia la resoluciÃ³n. Buscar feedback es afrontamiento activo alineado con su valor de crecimiento profesional.",
          wrong: "Esto es TRAC: a pesar de la decepciÃ³n, Diego toma acciÃ³n orientada a resolver (pedir feedback). Esto rompe el patrÃ³n de evitaciÃ³n y se alinea con sus valores de crecimiento."
        }
      },
      {
        text: `SofÃ­a se siente abrumada por las deudas ğŸ˜©. Se pasa toda la noche leyendo artÃ­culos sobre "cÃ³mo salir de deudas" y viendo videos de finanzas, pero no hace un presupuesto ni llama al banco ğŸ“š.`,
        correct: "TRAP",
        feedback: {
          correct: "Â¡Bien visto! ğŸ¯ Informarse PARECE productivo, pero su funciÃ³n es evitar la acciÃ³n concreta (hacer presupuesto, llamar al banco). Es evitaciÃ³n intelectualizada.",
          wrong: "Esto es TRAP: aunque parece que SofÃ­a estÃ¡ 'haciendo algo' (investigar), la funciÃ³n real es evitar las acciones concretas que resolverÃ­an el problema. Leer sobre deudas no es lo mismo que abordarlas."
        }
      },
    ],
  },
  {
    type: "unmask_avoidance",
    instruction: "ğŸ­ Detecta la evitaciÃ³n encubierta. En cada par de conductas ante la MISMA situaciÃ³n, identifica cuÃ¡l es evitaciÃ³n disfrazada y cuÃ¡l es afrontamiento real.",
    pairs: [
      {
        situation: "Trigger: Tu amigo te confronta por algo que le molestÃ³ ğŸ˜¤\nResponse: Te sientes incÃ³modo/a y a la defensiva ğŸ˜£",
        optionA: "Le dices \"tienes razÃ³n, perdÃ³n\" rÃ¡pidamente para que se termine la conversaciÃ³n",
        optionB: "Le dices \"entiendo que te molestÃ³, cuÃ©ntame mÃ¡s\" aunque te incomoda",
        avoidance: "A",
        feedback: {
          correct: "Â¡Exacto! ğŸ¯ La opciÃ³n A parece madura (pedir perdÃ³n), pero su FUNCIÃ“N es terminar la incomodidad lo antes posible, sin realmente escuchar ni resolver. La opciÃ³n B mantiene la incomodidad pero abre el diÃ¡logo real.",
          wrong: "La opciÃ³n A es evitaciÃ³n disfrazada: decir \"perdÃ³n\" rÃ¡pido PARECE maduro, pero su funciÃ³n es escapar de la incomodidad, no resolver el conflicto. La B es incÃ³moda pero es afrontamiento real."
        }
      },
      {
        situation: "Trigger: Llevas semanas sin buscar trabajo despuÃ©s de ser despedido ğŸ’¼\nResponse: Te sientes ansioso/a y avergonzado/a ğŸ˜°",
        optionA: "Actualizas tu perfil de LinkedIn y pasas 2 horas arreglando la foto y el diseÃ±o",
        optionB: "EnvÃ­as 3 currÃ­culums a ofertas concretas aunque tu CV no estÃ© perfecto",
        avoidance: "A",
        feedback: {
          correct: "Â¡Bien! ğŸ¯ Arreglar LinkedIn PARECE productivo, pero perfeccionar la foto y el diseÃ±o funciona como procrastinaciÃ³n sofisticada. Enviar CVs imperfectos es acciÃ³n real que contacta con reforzadores potenciales.",
          wrong: "La opciÃ³n A es evitaciÃ³n disfrazada: \"arreglar el perfil\" da sensaciÃ³n de productividad pero evita la acciÃ³n que realmente importa (aplicar a trabajos). La B es imperfecta pero es afrontamiento real."
        }
      },
      {
        situation: "Trigger: Tu psicÃ³logo/a te sugiriÃ³ hacer actividades sociales ğŸ‘¥\nResponse: Te sientes ansioso/a y sin ganas ğŸ˜“",
        optionA: "Vas a un cafÃ© pero te sientas solo/a con audÃ­fonos puestos durante 1 hora",
        optionB: "Llamas a un amigo para tomar un cafÃ© juntos aunque te sientas sin energÃ­a",
        avoidance: "A",
        feedback: {
          correct: "Â¡Perfecto! ğŸ¯ Ir al cafÃ© con audÃ­fonos cumple 'tÃ©cnicamente' con la indicaciÃ³n pero evita completamente la interacciÃ³n social. Es la forma mÃ¡s sofisticada de evitaciÃ³n: hacer lo mÃ­nimo para decir 'lo intentÃ©'.",
          wrong: "La opciÃ³n A es evitaciÃ³n encubierta brillante: puedes decir \"fui a un cafÃ©\" pero con audÃ­fonos evitaste toda interacciÃ³n. La funciÃ³n era cumplir 'en papel' sin exponerte realmente."
        }
      },
    ],
  },
  {
    type: "expert_trap",
    instruction: "âš¡ TRAMPA DEL EXPERTO âš¡\nEste requiere pensar con mucho cuidado.",
    scenario: `Marcos se siente deprimido y su terapeuta le recomendÃ³ activaciÃ³n conductual. Marcos decide crear un plan detallado: arma una hoja de cÃ¡lculo con 15 actividades clasificadas por tipo, horarios Ã³ptimos, y un sistema de puntos para medir su progreso. Dedica todo el fin de semana a perfeccionar el plan. El lunes, se siente cansado y no hace ninguna actividad del plan.`,
    question: "La conducta de Marcos de armar el plan elaborado es...",
    options: [
      { text: "Afrontamiento â€” estÃ¡ siguiendo las recomendaciones de su terapeuta y organizÃ¡ndose", isCorrect: false },
      { text: "EvitaciÃ³n disfrazada â€” la planificaciÃ³n excesiva reemplazÃ³ a la acciÃ³n real y funcionÃ³ como escape", isCorrect: true },
      { text: "Un paso necesario â€” siempre hay que planificar antes de actuar", isCorrect: false },
    ],
    feedback: {
      correct: "ğŸ† Â¡BRILLANTE! La planificaciÃ³n excesiva es una de las formas mÃ¡s elegantes de evitaciÃ³n. Marcos pasa de \"necesito activarme\" a \"necesito el plan perfecto para activarme\", lo cual es una TRAMPA dentro de la trampa. La AC dice: empieza con algo PEQUEÃ‘O y FACTIBLE, no con el sistema perfecto. La funciÃ³n del plan era dar sensaciÃ³n de control sin asumir el riesgo real de actuar.",
      wrong: "ğŸª¤ Â¡La trampa clÃ¡sica de la planificaciÃ³n! Marcos convirtiÃ³ la activaciÃ³n en otro proyecto de evitaciÃ³n. Dedicar un fin de semana entero a un plan que nunca ejecuta revela la funciÃ³n real: la planificaciÃ³n REEMPLAZÃ“ la acciÃ³n. En AC, es mejor un plan imperfecto que se ejecuta que un plan perfecto que se admira."
    },
  },
];

// ====== LEVEL 3 CONTENT ======
const L3_THEORY = [
  {
    title: "El arte de construir afrontamientos alternativos ğŸ”§",
    content: `Ya sabes identificar TRAPs y distinguir TRAP de TRAC. Ahora viene la habilidad mÃ¡s importante: **construir buenos afrontamientos alternativos**.\n\nNo cualquier acciÃ³n es un buen afrontamiento. Un buen afrontamiento alternativo cumple con criterios especÃ­ficos que vamos a aprender.\n\n**Â¿Para quÃ© sirve esto?**\nEn la prÃ¡ctica clÃ­nica, el terapeuta ayuda al cliente a generar alternativas. Pero no vale cualquier sugerencia. Un mal afrontamiento alternativo puede ser tan inÃºtil como la evitaciÃ³n misma.\n\nAprender a construir buenos afrontamientos es lo que separa un anÃ¡lisis superficial de uno que realmente mueve al cliente hacia el cambio.`,
  },
  {
    title: "Los 4 criterios de un buen Afrontamiento Alternativo âœ…",
    content: `Para que un afrontamiento alternativo sea efectivo, debe cumplir:\n\n**1. ğŸ¯ Rompe el patrÃ³n de evitaciÃ³n**\nDebe ser algo DIFERENTE a lo que la persona hace habitualmente. Si siempre se aÃ­sla, el afrontamiento debe implicar contacto. Si siempre pospone, debe implicar acciÃ³n inmediata.\n\n**2. ğŸ’ EstÃ¡ alineado con los valores de la persona**\nDebe conectar con lo que la persona considera importante: familia, trabajo, salud, amistad. Si no conecta con un valor, se siente vacÃ­o y no se mantiene.\n\n**3. ğŸŒ± Contacta con fuentes de reforzamiento positivo**\nDebe poner a la persona en situaciones donde pueda recibir algo positivo: reconocimiento, logro, placer, conexiÃ³n. La evitaciÃ³n aleja de los reforzadores; el afrontamiento acerca.\n\n**4. ğŸ“ Es especÃ­fico, concreto y factible**\nNada de "voy a ser mÃ¡s positivo" o "intentarÃ© salir mÃ¡s". Debe ser una acciÃ³n concreta que se pueda hacer HOY o ESTA SEMANA: "LlamarÃ© a Elena el martes a las 6pm".`,
  },
  {
    title: "Errores comunes al construir afrontamientos ğŸš«",
    content: `Conocer los errores te ayudarÃ¡ a evitarlos:\n\n**âŒ Error 1: Demasiado ambicioso**\n"Voy a empezar a ir al gimnasio todos los dÃ­as" cuando no sales de casa hace un mes. La AC dice: **empieza pequeÃ±o**. Un paseo de 10 minutos es mejor punto de partida.\n\n**âŒ Error 2: Depende del estado de Ã¡nimo**\n"Cuando me sienta mejor, llamarÃ© a mi amigo." Esto NO es afrontamiento, es posponer condicionado a la emociÃ³n. El afrontamiento se hace A PESAR de cÃ³mo te sientes.\n\n**âŒ Error 3: Es vago e inespecÃ­fico**\n"Voy a intentar ser mÃ¡s social." Â¿QuÃ© significa eso? Â¿CuÃ¡ndo? Â¿Con quiÃ©n? Sin especificidad no hay compromiso real.\n\n**âŒ Error 4: No conecta con valores**\n"Voy a limpiar la casa" como afrontamiento para alguien cuyo valor es la conexiÃ³n social. Puede ser Ãºtil, pero no ataca el nÃºcleo del problema.\n\n**âŒ Error 5: Es evitaciÃ³n reempaquetada**\n"Voy a meditar para no pensar en el problema." Si la funciÃ³n es no pensar (escapar), sigue siendo evitaciÃ³n con disfraz de mindfulness.`,
  },
];

const L3_EXERCISES = [
  {
    type: "choose_best_coping",
    instruction: "Dado el TRAP completo, elige el MEJOR afrontamiento alternativo. Â¡Cuidado con las trampas!",
    cases: [
      {
        trap: {
          T: "Laura no recibiÃ³ invitaciÃ³n a la boda de su prima ğŸ’Œ",
          R: "Se siente herida y rechazada por su familia ğŸ’”",
          AP: "DejÃ³ de asistir a las reuniones familiares y borrÃ³ el chat grupal ğŸšª",
        },
        value: "Laura valora profundamente las relaciones familiares",
        options: [
          { text: "Publicar una indirecta en redes sociales sobre la familia tÃ³xica", isCorrect: false, reason: "Esto es agresiÃ³n pasiva, otra forma de evitaciÃ³n del conflicto real. No se acerca a lo que valora." },
          { text: "Llamar a su prima para expresar cÃ³mo se siente y preguntar si hubo un malentendido", isCorrect: true, reason: "Rompe el patrÃ³n (en vez de aislarse, busca contacto). EstÃ¡ alineada con su valor (familia). Es especÃ­fica y concreta. Contacta con reforzadores potenciales (resolver el conflicto)." },
          { text: "Ir a la boda sin invitaciÃ³n para demostrar que no le afecta", isCorrect: false, reason: "Parece 'valiente' pero su funciÃ³n es demostrar algo, no resolver. AdemÃ¡s es impositivo y puede generar mÃ¡s conflicto." },
          { text: "Esperar a que se le pase el enojo y luego decidir quÃ© hacer", isCorrect: false, reason: "ClÃ¡sico 'esperar a sentirme mejor'. Esto es evitar condicionado al estado de Ã¡nimo. En AC actuamos segÃºn valores, no segÃºn emociones." },
        ],
      },
      {
        trap: {
          T: "Jorge fue despedido de su trabajo hace 3 meses ğŸ’¼",
          R: "Se siente avergonzado, inÃºtil y sin motivaciÃ³n ğŸ˜",
          AP: "Se queda en casa todo el dÃ­a, no busca empleo, les dice a todos que 'estÃ¡ descansando' ğŸ›‹ï¸",
        },
        value: "Jorge valora la estabilidad econÃ³mica y sentirse productivo",
        options: [
          { text: "Inscribirse en un curso online de 6 meses sobre una nueva carrera", isCorrect: false, reason: "Demasiado ambicioso y lejano. Un curso de 6 meses puede funcionar como evitaciÃ³n sofisticada: 'estoy estudiando' sin buscar empleo. No rompe el patrÃ³n inmediato." },
          { text: "Enviar su CV a 2 ofertas laborales esta semana, aunque no se sienta listo", isCorrect: true, reason: "EspecÃ­fico (2 ofertas, esta semana). Factible (no 20, sino 2). Rompe el patrÃ³n (sale de la inacciÃ³n). Se hace A PESAR de no sentirse listo. Alineado con sus valores." },
          { text: "Ir al gimnasio para sentirse mejor consigo mismo primero", isCorrect: false, reason: "El gimnasio no es malo, pero aquÃ­ funciona como 'necesito sentirme bien antes de actuar'. No aborda el problema central ni conecta con su valor de productividad." },
          { text: "Contarle la verdad a su familia sobre el despido", isCorrect: false, reason: "Puede ser Ãºtil eventualmente, pero no es el afrontamiento mÃ¡s directo a su patrÃ³n de evitaciÃ³n laboral. El problema central es la inactividad en la bÃºsqueda, no el secreto." },
        ],
      },
      {
        trap: {
          T: "Valentina tuvo una discusiÃ³n fuerte con su mejor amiga ğŸ˜¡",
          R: "Se siente triste, ansiosa y con miedo de perder la amistad ğŸ˜¢",
          AP: "Evita todos los lugares donde podrÃ­a encontrÃ¡rsela y no responde sus mensajes ğŸ“µ",
        },
        value: "Valentina valora la lealtad y las amistades profundas",
        options: [
          { text: "Responder el Ãºltimo mensaje de su amiga proponiendo verse para conversar el jueves", isCorrect: true, reason: "EspecÃ­fico (responder, proponer fecha). Rompe el patrÃ³n (en vez de evitar, inicia contacto). Alineado con su valor (amistad). Factible (un mensaje, una fecha). Pone en contacto con reforzadores (reconexiÃ³n)." },
          { text: "Escribirle una carta larga explicando todos sus sentimientos", isCorrect: false, reason: "Parece profundo pero puede funcionar como forma de controlar la interacciÃ³n: dice todo SIN escuchar. El afrontamiento real implica diÃ¡logo bidireccional, no monÃ³logo." },
          { text: "Buscar nuevas amistades para no depender tanto de una sola persona", isCorrect: false, reason: "Suena razonable pero es evitaciÃ³n: en vez de afrontar ESTE conflicto, busca reemplazar la relaciÃ³n. No estÃ¡ alineado con su valor de lealtad." },
          { text: "Esperar unos dÃ­as hasta que ambas se calmen", isCorrect: false, reason: "La trampa del 'esperar': suena prudente pero es evitaciÃ³n temporal. Â¿CuÃ¡ntos dÃ­as? Â¿Y si nunca se 'calma' lo suficiente? El afrontamiento no depende de la emociÃ³n." },
        ],
      },
    ],
  },
  {
    type: "justify_criteria",
    instruction: "Se te presenta un afrontamiento alternativo ya elegido. Identifica CUÃLES criterios cumple y cuÃ¡les NO.",
    cases: [
      {
        context: "Persona que evita hablar en reuniones de trabajo por miedo al rechazo. Valora el crecimiento profesional.",
        coping: "Preparar una intervenciÃ³n de 2 minutos para la prÃ³xima reuniÃ³n y decirla aunque sienta nervios.",
        criteria: [
          { name: "Rompe el patrÃ³n", met: true, explanation: "En vez de callarse (lo habitual), habla. Es lo opuesto a la evitaciÃ³n." },
          { name: "Alineado con valores", met: true, explanation: "Su valor es el crecimiento profesional, y participar activamente contribuye a eso." },
          { name: "Contacta con reforzadores", met: true, explanation: "Puede recibir reconocimiento, feedback, sensaciÃ³n de logro." },
          { name: "EspecÃ­fico y factible", met: true, explanation: "2 minutos, prÃ³xima reuniÃ³n, preparado. Concreto y realizable." },
        ],
      },
      {
        context: "Persona que dejÃ³ de cocinar y solo come comida chatarra/delivery desde que se deprimiÃ³. Valora su salud.",
        coping: "Proponerse cocinar todos los dÃ­as de la semana comidas saludables desde cero.",
        criteria: [
          { name: "Rompe el patrÃ³n", met: true, explanation: "SÃ­, cambiar de delivery a cocinar es diferente a lo habitual." },
          { name: "Alineado con valores", met: true, explanation: "Conecta con su valor de salud." },
          { name: "Contacta con reforzadores", met: true, explanation: "Puede sentir logro, mejor salud, placer de cocinar." },
          { name: "EspecÃ­fico y factible", met: false, explanation: "âŒ 'Todos los dÃ­as, desde cero' es demasiado ambicioso para alguien que no cocina hace meses. Mejor: 'cocinar UNA cena el miÃ©rcoles con receta simple'." },
        ],
      },
    ],
  },
  {
    type: "expert_trap",
    instruction: "âš¡ TRAMPA DEL EXPERTO âš¡\nEste ejercicio pone a prueba tu comprensiÃ³n funcional.",
    scenario: `Rodrigo estÃ¡ deprimido y aislado. Su terapeuta le propone como afrontamiento alternativo: "Ir a un parque cercano y sentarse en un banco 30 minutos". Rodrigo cumple: va al parque, se sienta 30 minutos con audÃ­fonos escuchando mÃºsica triste, mirando el piso, y se va. CumpliÃ³ con la tarea.`,
    question: "Â¿Rodrigo realmente hizo un afrontamiento alternativo?",
    options: [
      { text: "SÃ­ â€” cumpliÃ³ la tarea tal como se la propusieron, fue al parque", isCorrect: false },
      { text: "No â€” la forma en que lo hizo convirtiÃ³ el afrontamiento en evitaciÃ³n: estaba presente fÃ­sicamente pero ausente conductualmente", isCorrect: true },
      { text: "Parcialmente â€” hizo el esfuerzo de salir y eso ya cuenta", isCorrect: false },
    ],
    feedback: {
      correct: "ğŸ† Â¡MAESTRO del anÃ¡lisis funcional! La conducta TOPOGRÃFICA (ir al parque) se cumpliÃ³, pero la conducta FUNCIONAL no. Rodrigo llevÃ³ su evitaciÃ³n AL parque: audÃ­fonos = barrera social, mÃºsica triste = mantenimiento del estado de Ã¡nimo, mirar el piso = evitar contacto con el entorno. Este es un ejemplo perfecto de por quÃ© en AC analizamos la FUNCIÃ“N, no solo la FORMA. Un buen seguimiento serÃ­a: ir al parque SIN audÃ­fonos y observar activamente lo que hay alrededor.",
      wrong: "ğŸª¤ AquÃ­ estÃ¡ la lecciÃ³n mÃ¡s importante del anÃ¡lisis funcional: **la forma no es la funciÃ³n**. Rodrigo fue al parque (forma), pero mantuvo toda su evitaciÃ³n (funciÃ³n): audÃ­fonos como barrera, mÃºsica triste, cero contacto con el entorno. LlevÃ³ su aislamiento consigo. En AC miramos QUÃ‰ FUNCIÃ“N cumple la conducta, no solo si se ejecutÃ³."
    },
  },
];

// ====== LEVEL 4 CONTENT ======
const L4_INTRO = {
  title: "Bienvenido/a a la Consulta Simulada ğŸ¯",
  content: `Has llegado al nivel final. AquÃ­ no hay teorÃ­a nueva: vas a **usar todo lo aprendido** en un caso clÃ­nico que se desarrolla en tiempo real.\n\nVas a conocer a **Camila**, y a lo largo de varias etapas vas a:\n\n1. ğŸ” Identificar sus TRAPs\n2. ğŸ§  Analizar las funciones de sus conductas\n3. ğŸ”§ Proponer rutas TRAC\n4. âš¡ Manejar complicaciones y recaÃ­das\n\n**Tus decisiones importan**: segÃºn lo que elijas, el caso evoluciona diferente.\n\nEsto es lo mÃ¡s cercano a una interacciÃ³n clÃ­nica real. No hay respuestas obvias. Piensa funcionalmente.\n\nÂ¿Listo/a? Conoce a Camila. ğŸ‘‡`,
};

const L4_CASE = {
  intro: `**Camila, 28 aÃ±os** ğŸ‘©\n\nCamila era una diseÃ±adora grÃ¡fica freelance muy activa hasta hace 6 meses, cuando terminÃ³ una relaciÃ³n de 4 aÃ±os. Desde entonces:\n\nğŸ˜” DejÃ³ de aceptar proyectos de diseÃ±o ("no tengo creatividad")\nğŸ›‹ï¸ Pasa la mayor parte del dÃ­a en su departamento viendo series\nğŸ“± Revisa obsesivamente las redes de su ex\nğŸš« CancelÃ³ planes con amigas mÃ¡s de 10 veces\nğŸ˜´ Duerme entre 12-14 horas diarias\n\nCamila dice: "No es que no quiera hacer cosas... es que no me sale. Me siento vacÃ­a. Es como si todo lo que me gustaba ya no tuviera color."`,
  
  stages: [
    {
      id: "identify_traps",
      title: "Etapa 1: Identifica los TRAPs de Camila ğŸ”",
      description: "Camila tiene MÃšLTIPLES patrones de evitaciÃ³n operando al mismo tiempo. Identifica el TRAP mÃ¡s importante para abordar primero.",
      question: "Â¿CuÃ¡l es el TRAP prioritario para trabajar primero con Camila?",
      options: [
        {
          text: "T: Ruptura â†’ R: VacÃ­o â†’ AP: Revisar redes del ex",
          feedback: "Revisar las redes del ex es problemÃ¡tico, pero no es el TRAP mÃ¡s estratÃ©gico para abordar primero. Es un patrÃ³n de evitaciÃ³n, sÃ­, pero trabajar en este directamente podrÃ­a ser demasiado emocionalmente cargado al inicio. AdemÃ¡s, si Camila retoma actividades y contacto social, este patrÃ³n puede reducirse naturalmente.",
          isOptimal: false,
          consequence: "suboptimal_path",
        },
        {
          text: "T: Ruptura â†’ R: VacÃ­o/Tristeza â†’ AP: Dejar de aceptar proyectos y aislarse",
          feedback: "Â¡Excelente elecciÃ³n clÃ­nica! ğŸ¯ Este TRAP es el mÃ¡s estratÃ©gico porque: abarca las DOS Ã¡reas mÃ¡s afectadas (trabajo y social), es donde mÃ¡s reforzadores se han perdido, y generar activaciÃ³n aquÃ­ puede tener efecto cascada en los otros patrones. El letargo produce letargo, pero la actividad tambiÃ©n produce actividad.",
          isOptimal: true,
          consequence: "optimal_path",
        },
        {
          text: "T: Ruptura â†’ R: Fatiga â†’ AP: Dormir 12-14 horas",
          feedback: "El sueÃ±o excesivo es un sÃ­ntoma importante, pero en AC lo abordamos indirectamente. Si Camila empieza a activarse durante el dÃ­a (proyectos, contacto social), el patrÃ³n de sueÃ±o suele regularse. Atacar el sueÃ±o directamente ('duerme menos') sin darle algo que hacer es frustrante y poco efectivo.",
          isOptimal: false,
          consequence: "suboptimal_path",
        },
      ],
    },
    {
      id: "propose_trac_optimal",
      title: "Etapa 2: PropÃ³n el primer paso TRAC ğŸ”§",
      description: "Buen anÃ¡lisis. Ahora necesitas proponer un afrontamiento alternativo para Camila. Recuerda: empieza pequeÃ±o, especÃ­fico y alineado con sus valores.",
      question: "Â¿CuÃ¡l serÃ­a el mejor primer afrontamiento alternativo para Camila?",
      options: [
        {
          text: "Que retome un proyecto de diseÃ±o grande para un cliente anterior",
          feedback: "Demasiado ambicioso para alguien que lleva 6 meses inactiva. Un proyecto grande puede ser abrumador y si no lo completa, confirma su creencia de 'no tengo creatividad'. En AC empezamos PEQUEÃ‘O para garantizar Ã©xito.",
          isOptimal: false,
          next: "complication_overwhelm",
        },
        {
          text: "Que haga un diseÃ±o pequeÃ±o y personal (no para cliente) + que invite a UNA amiga a tomar cafÃ© esta semana",
          feedback: "ğŸ¯ Â¡Perfecto manejo clÃ­nico! Dos acciones pequeÃ±as que cubren las dos Ã¡reas afectadas. El diseÃ±o personal quita la presiÃ³n del cliente (reduce barrera), y una amiga (no todas) es factible. Ambas son especÃ­ficas, concretas, y contactan con reforzadores.",
          isOptimal: true,
          next: "complication_partial",
        },
        {
          text: "Que empiece por regular el sueÃ±o: poner alarma a las 8am y no volver a la cama",
          feedback: "Buena intenciÃ³n pero abordar el sueÃ±o sin actividades alternativas es como decir 'despiÃ©rtate temprano... Â¿para quÃ©?' Sin algo que hacer, Camila estarÃ¡ despierta, sola, y deprimida. Primero las actividades, el sueÃ±o se ajusta despuÃ©s.",
          isOptimal: false,
          next: "complication_no_purpose",
        },
      ],
    },
    {
      id: "complication_partial",
      title: "Etapa 3: La complicaciÃ³n âš¡",
      description: `Camila regresa la siguiente semana:\n\n"Hice el diseÃ±o... bueno, empecÃ© uno. Hice un bosquejo y me gustÃ³, pero despuÃ©s pensÃ© 'esto no es tan bueno como lo que hacÃ­a antes' y lo dejÃ©. Con lo del cafÃ©... le escribÃ­ a mi amiga Daniela pero me dijo que estaba ocupada. No le escribÃ­ a nadie mÃ¡s. Me sentÃ­ peor. Creo que esto no funciona."`,
      question: "Â¿CÃ³mo respondes a esta situaciÃ³n?",
      options: [
        {
          text: "Validar su frustraciÃ³n y seÃ±alar que dejÃ³ el diseÃ±o y no intentÃ³ con otra amiga como patrones de evitaciÃ³n que debemos trabajar",
          feedback: "Entendible, pero en este momento Camila necesita primero sentir que SÃ logrÃ³ cosas. Si vas directo a seÃ±alar la evitaciÃ³n sin validar los logros, puedes perder su motivaciÃ³n y la alianza terapÃ©utica.",
          isOptimal: false,
        },
        {
          text: "Destacar que SÃ empezÃ³ un bosquejo y SÃ escribiÃ³ a Daniela (reforzar conducta de acercamiento), y luego analizar quÃ© pasÃ³ con el pensamiento 'no es tan bueno' y con no escribir a alguien mÃ¡s",
          feedback: "ğŸ¯ Â¡Manejo experto! Primero refuerzas las conductas de acercamiento (empezÃ³ a diseÃ±ar, escribiÃ³ a Daniela) â€” esto es crucial en AC. Luego, analizas los dos puntos de quiebre: el pensamiento autocrÃ­tico que funcionÃ³ como trigger de un nuevo TRAP, y el patrÃ³n de 'un intento y me rindo'. Validas Y desafÃ­as.",
          isOptimal: true,
        },
        {
          text: "Decirle que es normal y que la prÃ³xima semana intente de nuevo lo mismo",
          feedback: "Repetir exactamente lo mismo sin analizar quÃ© pasÃ³ es perder informaciÃ³n valiosa. Lo que pasÃ³ esta semana NOS DICE COSAS: el pensamiento autocrÃ­tico es un nuevo trigger, y el patrÃ³n de 'un intento' es evitaciÃ³n. Sin ajustar, la prÃ³xima semana probablemente sea igual.",
          isOptimal: false,
        },
      ],
    },
    {
      id: "complication_next",
      title: "Etapa 4: Ajustar y avanzar ğŸ“ˆ",
      description: `DespuÃ©s de analizar juntos lo que pasÃ³, Camila dice:\n\n"Ok, entiendo que el pensamiento 'no es tan bueno' me hizo parar. Y sÃ­, cuando Daniela dijo que no, me rendÃ­. Pero es que... Â¿y si realmente mis diseÃ±os ya no son buenos? Â¿Y si a mis amigas ya no les importo?"\n\nEstos pensamientos estÃ¡n funcionando como nuevos desencadenantes de evitaciÃ³n.`,
      question: "Â¿CuÃ¡l es la mejor respuesta desde la AC?",
      options: [
        {
          text: "Reestructurar los pensamientos: ayudarle a ver que no son verdad, que sus diseÃ±os sÃ­ son buenos y sus amigas sÃ­ la quieren",
          feedback: "La AC NO se centra en cambiar el contenido de los pensamientos. En AC, los pensamientos son conductas que tienen funciÃ³n. Decirle 'tus diseÃ±os sÃ­ son buenos' no cambia el patrÃ³n. La pregunta no es si el pensamiento es verdad, sino quÃ© HACE Camila cuando lo tiene.",
          isOptimal: false,
        },
        {
          text: "Reconocer los pensamientos como conductas con funciÃ³n de evitaciÃ³n, y preguntarle: 'Â¿QuÃ© haces cuando aparece ese pensamiento? Â¿Y quÃ© pasa despuÃ©s?'",
          feedback: "ğŸ¯ Â¡Exactamente AC! En vez de debatir si los pensamientos son verdad, los tratas como conductas que tienen antecedentes, funciones y consecuencias. La rumiaciÃ³n ('Â¿y si no soy buena?') funciona como un nuevo patrÃ³n de evitaciÃ³n: mientras piensa, no actÃºa. La pregunta la ayuda a ver ESA conexiÃ³n.",
          isOptimal: true,
        },
        {
          text: "Sugerirle que practique mindfulness para aceptar esos pensamientos sin juzgarlos",
          feedback: "No estÃ¡ mal como complemento, pero en este momento de la terapia lo mÃ¡s importante es conectar los pensamientos con la evitaciÃ³n conductual, no introducir una tÃ©cnica nueva. Primero que entienda QUÃ‰ FUNCIÃ“N tienen esos pensamientos en su ciclo.",
          isOptimal: false,
        },
      ],
    },
    {
      id: "final",
      title: "Etapa Final: El cierre ğŸ",
      description: `Tres semanas despuÃ©s, Camila reporta:\n\n"TerminÃ© el bosquejo y lo publiquÃ© en Instagram. No es mi mejor trabajo pero lo hice. Una ex-clienta lo vio y me preguntÃ³ si estoy disponible para un proyecto pequeÃ±o. Y con Daniela nos vimos el jueves â€” fue raro al principio pero despuÃ©s estuvo bien. TodavÃ­a reviso las redes de mi ex a veces, pero menos. Sigo sintiÃ©ndome triste algunos dÃ­as, pero ya no todos los dÃ­as."\n\nCamila aÃºn tiene camino por recorrer, pero los patrones estÃ¡n cambiando.`,
      question: "Para la prevenciÃ³n de recaÃ­das, Â¿quÃ© es lo mÃ¡s importante que Camila debe entender?",
      options: [
        {
          text: "Que ya estÃ¡ curada y debe mantener las actividades para no recaer",
          feedback: "No estÃ¡ 'curada' â€” la tristeza sigue ahÃ­ algunos dÃ­as y eso es normal. AdemÃ¡s, el marco de 'si paras recaes' genera presiÃ³n. Lo importante no es la perfecciÃ³n sino el proceso.",
          isOptimal: false,
        },
        {
          text: "Que habrÃ¡ dÃ­as difÃ­ciles y que los TRAPs volverÃ¡n, pero ahora tiene la habilidad de reconocerlos y elegir un TRAC en vez de quedar atrapada automÃ¡ticamente",
          feedback: "ğŸ¯ Â¡Cierre perfecto! La prevenciÃ³n de recaÃ­das en AC no es 'nunca mÃ¡s te sentirÃ¡s mal'. Es: cuando la trampa aparezca (y aparecerÃ¡), ahora tienes herramientas. Puedes reconocer el TRAP, elegir un TRAC, y saber que la acciÃ³n viene ANTES de la motivaciÃ³n. El objetivo no es eliminar las emociones difÃ­ciles sino cambiar la relaciÃ³n con ellas a travÃ©s de la acciÃ³n.",
          isOptimal: true,
        },
        {
          text: "Que debe dejar de seguir a su ex en redes como paso final de la terapia",
          feedback: "Puede ser Ãºtil eventualmente, pero no es 'el paso final'. Lo mÃ¡s importante en prevenciÃ³n de recaÃ­das es que Camila internalice el modelo: reconocer TRAPs â†’ elegir TRACs. El tema del ex es UN patrÃ³n entre varios.",
          isOptimal: false,
        },
      ],
    },
  ],
};

// ==================== COMPONENTS ====================

// Animated background particles
const Particles = () => {
  return (
    <div style={{ position: "fixed", inset: 0, pointerEvents: "none", overflow: "hidden", zIndex: 0 }}>
      {Array.from({ length: 20 }).map((_, i) => (
        <div
          key={i}
          style={{
            position: "absolute",
            width: `${6 + Math.random() * 12}px`,
            height: `${6 + Math.random() * 12}px`,
            borderRadius: "50%",
            background: ["#FF6B6B30", "#2EAF7030", "#E8A81730", "#9B59B630", "#E67E2230"][i % 5],
            left: `${Math.random() * 100}%`,
            top: `${Math.random() * 100}%`,
            animation: `floatParticle ${8 + Math.random() * 12}s ease-in-out infinite`,
            animationDelay: `${Math.random() * 5}s`,
          }}
        />
      ))}
    </div>
  );
};

// Skill thermometer
const SkillThermometer = ({ skills }) => {
  return (
    <div style={{ background: "#FFFFFF", borderRadius: 16, padding: 16, marginBottom: 20, boxShadow: "0 4px 16px #00000012" }}>
      <div style={{ fontSize: 14, fontWeight: 700, color: "#0d1b2a", marginBottom: 12, display: "flex", alignItems: "center", gap: 8 }}>
        ğŸŒ¡ï¸ TermÃ³metro de Habilidad
      </div>
      {skills.map((s, i) => (
        <div key={i} style={{ marginBottom: 10 }}>
          <div style={{ display: "flex", justifyContent: "space-between", fontSize: 12, color: "#4A6274", marginBottom: 4 }}>
            <span>{s.emoji} {s.name}</span>
            <span style={{ color: s.unlocked ? "#1A7A4A" : "#999" }}>{s.unlocked ? "âœ…" : "ğŸ”’"}</span>
          </div>
          <div style={{ height: 6, background: "#D0DDE6", borderRadius: 3, overflow: "hidden" }}>
            <div
              style={{
                height: "100%",
                width: `${s.progress}%`,
                background: s.unlocked ? `linear-gradient(90deg, ${s.color}, ${s.color}dd)` : "#444",
                borderRadius: 3,
                transition: "width 0.8s cubic-bezier(0.34, 1.56, 0.64, 1)",
              }}
            />
          </div>
        </div>
      ))}
    </div>
  );
};

// Theory card with rich text
const TheoryCard = ({ section, index, onNext, isLast }) => {
  const [visible, setVisible] = useState(false);
  useEffect(() => { setTimeout(() => setVisible(true), 100); }, []);

  const renderContent = (text) => {
    return text.split("\n").map((line, i) => {
      if (!line.trim()) return <br key={i} />;
      let processed = line;
      // Bold
      processed = processed.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#D4880F">$1</strong>');
      // Emoji bullets
      if (/^[âœ…âŒğŸ­âš ï¸ğŸ¯ğŸ’ğŸŒ±ğŸ“]/.test(processed.trim())) {
        return <p key={i} style={{ margin: "6px 0", paddingLeft: 8, fontSize: 15, lineHeight: 1.6 }} dangerouslySetInnerHTML={{ __html: processed }} />;
      }
      return <p key={i} style={{ margin: "8px 0", fontSize: 15, lineHeight: 1.7 }} dangerouslySetInnerHTML={{ __html: processed }} />;
    });
  };

  return (
    <div style={{
      opacity: visible ? 1 : 0,
      transform: visible ? "translateY(0)" : "translateY(30px)",
      transition: "all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)",
      background: "linear-gradient(145deg, #FFFFFF, #F5FAFF)",
      borderRadius: 20,
      padding: 24,
      marginBottom: 16,
      border: "1px solid #C0D8E8",
      boxShadow: "0 4px 20px #00000010",
    }}>
      <div style={{ fontSize: 11, color: "#1A7A4A", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
        ğŸ“– TeorÃ­a Â· SecciÃ³n {index + 1}
      </div>
      <h3 style={{ fontSize: 22, fontWeight: 800, color: "#0d1b2a", marginBottom: 16, lineHeight: 1.3 }}>
        {section.title}
      </h3>
      <div style={{ color: "#2C3E50" }}>
        {renderContent(section.content)}
      </div>
      <button
        onClick={onNext}
        style={{
          marginTop: 20,
          width: "100%",
          padding: "14px 24px",
          background: "linear-gradient(135deg, #4ECDC4, #44B3A8)",
          color: "#000",
          border: "none",
          borderRadius: 12,
          fontSize: 16,
          fontWeight: 700,
          cursor: "pointer",
          transition: "transform 0.2s",
        }}
        onMouseDown={e => e.target.style.transform = "scale(0.97)"}
        onMouseUp={e => e.target.style.transform = "scale(1)"}
      >
        {isLast ? "Â¡A practicar! ğŸ’ª" : "Siguiente â†’"}
      </button>
    </div>
  );
};

// Multiple choice exercise
const MCExercise = ({ question, options, onAnswer, answered, selectedIdx }) => {
  return (
    <div style={{ marginBottom: 16 }}>
      <p style={{ fontSize: 15, fontWeight: 600, color: "#0d1b2a", marginBottom: 12, lineHeight: 1.5 }}>{question.text || question}</p>
      <div style={{ display: "flex", flexDirection: "column", gap: 10 }}>
        {options.map((opt, i) => {
          const optText = typeof opt === "string" ? opt : opt.text;
          const isSelected = selectedIdx === i;
          const isCorrectOpt = typeof opt === "object" ? opt.isCorrect : (question.correct === i);
          let bg = "linear-gradient(145deg, #F0F6FC, #E6F0F9)";
          let border = "1px solid #ffffff20";
          if (answered) {
            if (isCorrectOpt) {
              bg = "linear-gradient(145deg, #D4F5E0, #C2EDCF)";
              border = "2px solid #4ECDC4";
            } else if (isSelected && !isCorrectOpt) {
              bg = "linear-gradient(145deg, #FDDEDE, #F9CCCC)";
              border = "2px solid #FF6B6B";
            }
          }
          return (
            <button
              key={i}
              onClick={() => !answered && onAnswer(i)}
              disabled={answered}
              style={{
                padding: "14px 16px",
                background: bg,
                border,
                borderRadius: 12,
                color: "#0d1b2a",
                fontSize: 14,
                textAlign: "left",
                cursor: answered ? "default" : "pointer",
                transition: "all 0.3s",
                lineHeight: 1.5,
                opacity: answered && !isSelected && !isCorrectOpt ? 0.5 : 1,
              }}
            >
              <span style={{ fontWeight: 700, marginRight: 8, color: "#FFE66D" }}>
                {String.fromCharCode(65 + i)}.
              </span>
              {optText}
              {answered && isCorrectOpt && " âœ…"}
              {answered && isSelected && !isCorrectOpt && " âŒ"}
            </button>
          );
        })}
      </div>
    </div>
  );
};

// Feedback display
const FeedbackBox = ({ text, isCorrect }) => {
  const [visible, setVisible] = useState(false);
  useEffect(() => { setTimeout(() => setVisible(true), 100); }, []);
  return (
    <div style={{
      opacity: visible ? 1 : 0,
      transform: visible ? "translateY(0)" : "translateY(20px)",
      transition: "all 0.5s ease-out",
      padding: 16,
      borderRadius: 14,
      background: isCorrect
        ? "linear-gradient(145deg, #D4F5E0, #C2EDCF)"
        : "linear-gradient(145deg, #FDDEDE, #F9CCCC)",
      border: `2px solid ${isCorrect ? "#2EAF70" : "#E74C3C"}`,
      marginTop: 12,
      marginBottom: 16,
    }}>
      <div style={{ fontSize: 13, fontWeight: 600, color: isCorrect ? "#1A7A4A" : "#C0392B", marginBottom: 6 }}>
        {isCorrect ? "âœ¨ Â¡Correcto!" : "ğŸ’¡ RetroalimentaciÃ³n:"}
      </div>
      <div style={{ fontSize: 14, color: "#2C3E50", lineHeight: 1.6 }}
        dangerouslySetInnerHTML={{ __html: text.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#D4880F">$1</strong>') }}
      />
    </div>
  );
};

// Classify / drag exercise (tap-based for mobile)
const ClassifyExercise = ({ exercise, onComplete }) => {
  const [assignments, setAssignments] = useState({});
  const [currentItem, setCurrentItem] = useState(null);
  const [checked, setChecked] = useState(false);
  const [score, setScore] = useState(0);
  const categories = ["T", "R", "AP"];
  const catLabels = { T: "ğŸ’¥ Trigger", R: "ğŸ˜° Response", AP: "ğŸ”„ Avoidance Pattern" };
  const catColors = { T: "#E74C3C", R: "#D4880F", AP: "#8E44AD" };

  const handleAssign = (cat) => {
    if (currentItem === null || checked) return;
    setAssignments(prev => ({ ...prev, [currentItem]: cat }));
    setCurrentItem(null);
  };

  const handleCheck = () => {
    let correct = 0;
    exercise.items.forEach((item, i) => {
      if (assignments[i] === item.correct) correct++;
    });
    setScore(correct);
    setChecked(true);
  };

  const allAssigned = Object.keys(assignments).length === exercise.items.length;

  return (
    <div>
      <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 16 }}>Toca una frase y luego toca la categorÃ­a donde pertenece:</p>
      
      {/* Categories */}
      <div style={{ display: "flex", gap: 8, marginBottom: 16 }}>
        {categories.map(cat => (
          <button
            key={cat}
            onClick={() => handleAssign(cat)}
            disabled={currentItem === null || checked}
            style={{
              flex: 1,
              padding: "12px 8px",
              background: currentItem !== null ? `${catColors[cat]}20` : "#FFFFFF",
              border: `2px solid ${currentItem !== null ? catColors[cat] : "#C0D0DA"}`,
              borderRadius: 12,
              color: catColors[cat],
              fontSize: 11,
              fontWeight: 700,
              cursor: currentItem !== null ? "pointer" : "default",
              transition: "all 0.3s",
              textAlign: "center",
            }}
          >
            {catLabels[cat]}
          </button>
        ))}
      </div>

      {/* Items */}
      <div style={{ display: "flex", flexDirection: "column", gap: 8 }}>
        {exercise.items.map((item, i) => {
          const assigned = assignments[i];
          const isActive = currentItem === i;
          const isWrong = checked && assigned !== item.correct;
          const isRight = checked && assigned === item.correct;
          return (
            <button
              key={i}
              onClick={() => !checked && !assigned && setCurrentItem(i)}
              style={{
                padding: "12px 14px",
                background: isRight ? "#D4F5E0" : isWrong ? "#FDDEDE" : isActive ? "#E0EFFF" : assigned ? "#F5FAFF" : "#EDF4FA",
                border: `2px solid ${isRight ? "#2EAF70" : isWrong ? "#E74C3C" : isActive ? "#3498DB" : assigned ? catColors[assigned] + "80" : "#C0D0DA"}`,
                borderRadius: 12,
                color: "#0d1b2a",
                fontSize: 13,
                textAlign: "left",
                cursor: assigned || checked ? "default" : "pointer",
                transition: "all 0.3s",
                lineHeight: 1.5,
                position: "relative",
              }}
            >
              {item.text}
              {assigned && (
                <span style={{
                  position: "absolute", right: 10, top: "50%", transform: "translateY(-50%)",
                  fontSize: 11, fontWeight: 700, color: catColors[assigned],
                  background: `${catColors[assigned]}18`, padding: "2px 8px", borderRadius: 6,
                }}>
                  {catLabels[assigned]}
                  {checked && (isRight ? " âœ…" : " âŒ")}
                </span>
              )}
            </button>
          );
        })}
      </div>

      {!checked && allAssigned && (
        <button onClick={handleCheck} style={{
          marginTop: 16, width: "100%", padding: "14px",
          background: "linear-gradient(135deg, #E8A817, #D4960F)", color: "#FFFFFF",
          border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
        }}>
          Verificar respuestas âœ”ï¸
        </button>
      )}

      {checked && (
        <div style={{ marginTop: 16 }}>
          <FeedbackBox
            text={score === exercise.items.length
              ? "Â¡Todas correctas! Ya manejas los componentes del TRAP con soltura. ğŸ‰"
              : `Acertaste ${score} de ${exercise.items.length}. Revisa los elementos marcados en rojo â€” fÃ­jate en la diferencia entre lo que PASA (Trigger), lo que SIENTES (Response) y lo que HACES (Avoidance Pattern).`}
            isCorrect={score === exercise.items.length}
          />
          <button onClick={onComplete} style={{
            width: "100%", padding: "14px",
            background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            Continuar â†’
          </button>
        </div>
      )}
    </div>
  );
};

// TRAP or TRAC exercise (Level 2)
const TrapOrTracExercise = ({ exercise, onComplete }) => {
  const [currentIdx, setCurrentIdx] = useState(0);
  const [answered, setAnswered] = useState(false);
  const [selected, setSelected] = useState(null);
  const [correctCount, setCorrectCount] = useState(0);
  const scenario = exercise.scenarios[currentIdx];
  const isLast = currentIdx === exercise.scenarios.length - 1;

  const handleAnswer = (answer) => {
    setSelected(answer);
    setAnswered(true);
    if (answer === scenario.correct) setCorrectCount(c => c + 1);
  };

  const handleNext = () => {
    if (isLast) { onComplete(correctCount + (selected === scenario.correct ? 1 : 0)); return; }
    setCurrentIdx(i => i + 1);
    setAnswered(false);
    setSelected(null);
  };

  return (
    <div>
      <div style={{ fontSize: 12, color: "#1A7A4A", fontWeight: 700, marginBottom: 8 }}>
        Escenario {currentIdx + 1} de {exercise.scenarios.length}
      </div>
      <div style={{
        background: "#EDF4FA", borderRadius: 14, padding: 16, marginBottom: 16,
        border: "1px solid #D0E0EA", fontSize: 15, color: "#2C3E50", lineHeight: 1.7,
      }}
        dangerouslySetInnerHTML={{ __html: scenario.text.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#D4880F">$1</strong>') }}
      />
      
      {!answered ? (
        <div style={{ display: "flex", gap: 12 }}>
          <button onClick={() => handleAnswer("TRAP")} style={{
            flex: 1, padding: "16px",
            background: "linear-gradient(145deg, #FFF0F0, #FFE0E0)", border: "2px solid #E74C3C80",
            borderRadius: 14, color: "#C0392B", fontSize: 18, fontWeight: 800, cursor: "pointer",
          }}>
            ğŸª¤ TRAP
          </button>
          <button onClick={() => handleAnswer("TRAC")} style={{
            flex: 1, padding: "16px",
            background: "linear-gradient(145deg, #E8FAF0, #D4F5E0)", border: "2px solid #2EAF7080",
            borderRadius: 14, color: "#1A7A4A", fontSize: 18, fontWeight: 800, cursor: "pointer",
          }}>
            ğŸ’ª TRAC
          </button>
        </div>
      ) : (
        <>
          <FeedbackBox
            text={selected === scenario.correct ? scenario.feedback.correct : scenario.feedback.wrong}
            isCorrect={selected === scenario.correct}
          />
          <button onClick={handleNext} style={{
            width: "100%", padding: "14px",
            background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            {isLast ? "Completar ejercicio â†’" : "Siguiente escenario â†’"}
          </button>
        </>
      )}
    </div>
  );
};

// Unmask avoidance exercise (Level 2)
const UnmaskExercise = ({ exercise, onComplete }) => {
  const [currentIdx, setCurrentIdx] = useState(0);
  const [answered, setAnswered] = useState(false);
  const [selected, setSelected] = useState(null);
  const [correctCount, setCorrectCount] = useState(0);
  const pair = exercise.pairs[currentIdx];
  const isLast = currentIdx === exercise.pairs.length - 1;

  const handleAnswer = (answer) => {
    setSelected(answer);
    setAnswered(true);
    if (answer === pair.avoidance) setCorrectCount(c => c + 1);
  };

  const handleNext = () => {
    if (isLast) { onComplete(); return; }
    setCurrentIdx(i => i + 1);
    setAnswered(false);
    setSelected(null);
  };

  return (
    <div>
      <div style={{ fontSize: 12, color: "#D4880F", fontWeight: 700, marginBottom: 8 }}>
        Par {currentIdx + 1} de {exercise.pairs.length}
      </div>
      <div style={{
        background: "#EDF4FA", borderRadius: 14, padding: 14, marginBottom: 16,
        border: "1px solid #D0E0EA", fontSize: 14, color: "#2C3E50", lineHeight: 1.6,
      }}>
        {pair.situation.split("\n").map((l, i) => <p key={i} style={{ margin: "4px 0" }} dangerouslySetInnerHTML={{ __html: l.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#D4880F">$1</strong>') }} />)}
      </div>
      <p style={{ fontSize: 13, color: "#C0392B", fontWeight: 600, marginBottom: 12 }}>Â¿CuÃ¡l es la evitaciÃ³n disfrazada? ğŸ­</p>
      
      <div style={{ display: "flex", flexDirection: "column", gap: 10 }}>
        {["A", "B"].map(letter => {
          const text = letter === "A" ? pair.optionA : pair.optionB;
          const isSelected = selected === letter;
          const isAvoidance = pair.avoidance === letter;
          let bg = "linear-gradient(145deg, #F0F6FC, #E6F0F9)";
          let border = "1px solid #ffffff20";
          if (answered) {
            if (isAvoidance) { bg = "#FDDEDE"; border = "2px solid #FF6B6B"; }
            else { bg = "#D4F5E0"; border = "2px solid #4ECDC4"; }
          }
          return (
            <button key={letter} onClick={() => !answered && handleAnswer(letter)} disabled={answered} style={{
              padding: "14px 16px", background: bg, border, borderRadius: 12,
              color: "#0d1b2a", fontSize: 14, textAlign: "left", cursor: answered ? "default" : "pointer",
              transition: "all 0.3s", lineHeight: 1.5,
            }}>
              <span style={{ fontWeight: 700, color: "#FFE66D", marginRight: 8 }}>{letter}.</span>
              {text}
              {answered && isAvoidance && " ğŸ­ EvitaciÃ³n"}
              {answered && !isAvoidance && " ğŸ’ª Afrontamiento real"}
            </button>
          );
        })}
      </div>

      {answered && (
        <>
          <FeedbackBox text={selected === pair.avoidance ? pair.feedback.correct : pair.feedback.wrong} isCorrect={selected === pair.avoidance} />
          <button onClick={handleNext} style={{
            width: "100%", padding: "14px",
            background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            {isLast ? "Completar ejercicio â†’" : "Siguiente par â†’"}
          </button>
        </>
      )}
    </div>
  );
};

// Choose best coping exercise (Level 3)
const ChooseCopingExercise = ({ exercise, onComplete }) => {
  const [currentIdx, setCurrentIdx] = useState(0);
  const [answered, setAnswered] = useState(false);
  const [selectedIdx, setSelectedIdx] = useState(null);
  const [correctCount, setCorrectCount] = useState(0);
  const caseData = exercise.cases[currentIdx];
  const isLast = currentIdx === exercise.cases.length - 1;

  const handleAnswer = (i) => {
    setSelectedIdx(i);
    setAnswered(true);
    if (caseData.options[i].isCorrect) setCorrectCount(c => c + 1);
  };

  const handleNext = () => {
    if (isLast) { onComplete(); return; }
    setCurrentIdx(i => i + 1);
    setAnswered(false);
    setSelectedIdx(null);
  };

  return (
    <div>
      <div style={{ fontSize: 12, color: "#D4880F", fontWeight: 700, marginBottom: 8 }}>
        Caso {currentIdx + 1} de {exercise.cases.length}
      </div>
      {/* TRAP display */}
      <div style={{ background: "#FFF5F5", borderRadius: 14, padding: 14, marginBottom: 10, border: "1px solid #E74C3C40" }}>
        <div style={{ fontSize: 12, color: "#C0392B", fontWeight: 700, marginBottom: 8 }}>ğŸª¤ TRAP identificado:</div>
        {Object.entries(caseData.trap).map(([key, val]) => (
          <p key={key} style={{ fontSize: 13, color: "#2C3E50", margin: "4px 0", lineHeight: 1.5 }}>
            <strong style={{ color: key === "T" ? "#E74C3C" : key === "R" ? "#D4880F" : "#8E44AD" }}>
              {key === "T" ? "ğŸ’¥ T:" : key === "R" ? "ğŸ˜° R:" : "ğŸ”„ AP:"}
            </strong> {val}
          </p>
        ))}
      </div>
      <div style={{ fontSize: 13, color: "#1A7A4A", fontStyle: "italic", marginBottom: 14, padding: "0 4px" }}>
        ğŸ’ {caseData.value}
      </div>

      <p style={{ fontSize: 14, fontWeight: 600, color: "#0d1b2a", marginBottom: 12 }}>Elige el MEJOR afrontamiento alternativo:</p>
      <div style={{ display: "flex", flexDirection: "column", gap: 10 }}>
        {caseData.options.map((opt, i) => {
          const isSelected = selectedIdx === i;
          let bg = "linear-gradient(145deg, #F0F6FC, #E6F0F9)";
          let border = "1px solid #ffffff20";
          if (answered) {
            if (opt.isCorrect) { bg = "#D4F5E0"; border = "2px solid #4ECDC4"; }
            else if (isSelected) { bg = "#FDDEDE"; border = "2px solid #FF6B6B"; }
          }
          return (
            <button key={i} onClick={() => !answered && handleAnswer(i)} disabled={answered} style={{
              padding: "14px 16px", background: bg, border, borderRadius: 12,
              color: "#0d1b2a", fontSize: 14, textAlign: "left", cursor: answered ? "default" : "pointer",
              transition: "all 0.3s", lineHeight: 1.5, opacity: answered && !isSelected && !opt.isCorrect ? 0.5 : 1,
            }}>
              {opt.text}
              {answered && opt.isCorrect && " âœ…"}
              {answered && isSelected && !opt.isCorrect && " âŒ"}
            </button>
          );
        })}
      </div>

      {answered && (
        <>
          <FeedbackBox
            text={caseData.options[selectedIdx].isCorrect
              ? caseData.options[selectedIdx].reason
              : `${caseData.options[selectedIdx].reason}\n\n**La mejor opciÃ³n era:** "${caseData.options.find(o => o.isCorrect).text}" â€” ${caseData.options.find(o => o.isCorrect).reason}`}
            isCorrect={caseData.options[selectedIdx].isCorrect}
          />
          <button onClick={handleNext} style={{
            width: "100%", padding: "14px",
            background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            {isLast ? "Completar ejercicio â†’" : "Siguiente caso â†’"}
          </button>
        </>
      )}
    </div>
  );
};

// Criteria checker exercise (Level 3)
const CriteriaExercise = ({ exercise, onComplete }) => {
  const [currentIdx, setCurrentIdx] = useState(0);
  const [answers, setAnswers] = useState({});
  const [checked, setChecked] = useState(false);
  const caseData = exercise.cases[currentIdx];
  const isLast = currentIdx === exercise.cases.length - 1;

  const handleToggle = (i) => {
    if (checked) return;
    setAnswers(prev => ({ ...prev, [i]: !prev[i] }));
  };

  const handleCheck = () => setChecked(true);

  const handleNext = () => {
    if (isLast) { onComplete(); return; }
    setCurrentIdx(i => i + 1);
    setAnswers({});
    setChecked(false);
  };

  return (
    <div>
      <div style={{ fontSize: 12, color: "#D4880F", fontWeight: 700, marginBottom: 8 }}>
        AnÃ¡lisis {currentIdx + 1} de {exercise.cases.length}
      </div>
      <div style={{ background: "#EDF4FA", borderRadius: 14, padding: 14, marginBottom: 10, border: "1px solid #D0E0EA" }}>
        <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 8 }}>ğŸ“‹ Contexto: {caseData.context}</p>
        <p style={{ fontSize: 14, color: "#4ECDC4", fontWeight: 600 }}>ğŸ’ª Afrontamiento propuesto: "{caseData.coping}"</p>
      </div>

      <p style={{ fontSize: 13, color: "#0d1b2a", fontWeight: 600, marginBottom: 12 }}>
        Marca los criterios que SÃ cumple este afrontamiento:
      </p>

      {caseData.criteria.map((c, i) => {
        const userSaysMet = !!answers[i];
        const isCorrect = checked && userSaysMet === c.met;
        const isWrong = checked && userSaysMet !== c.met;
        return (
          <button
            key={i}
            onClick={() => handleToggle(i)}
            style={{
              display: "flex", alignItems: "center", gap: 12, width: "100%",
              padding: "12px 14px", marginBottom: 8,
              background: isCorrect ? "#D4F5E0" : isWrong ? "#FDDEDE" : userSaysMet ? "#E0EFFF" : "#EDF4FA",
              border: `2px solid ${isCorrect ? "#2EAF70" : isWrong ? "#E74C3C" : userSaysMet ? "#3498DB80" : "#C0D0DA"}`,
              borderRadius: 12, color: "#0d1b2a", fontSize: 14, textAlign: "left",
              cursor: checked ? "default" : "pointer", transition: "all 0.3s",
            }}
          >
            <span style={{
              width: 24, height: 24, borderRadius: 6, display: "flex", alignItems: "center", justifyContent: "center",
              background: userSaysMet ? "#2EAF70" : "#D0DDE6", color: "#FFFFFF", fontSize: 14, fontWeight: 700, flexShrink: 0,
            }}>
              {userSaysMet ? "âœ“" : ""}
            </span>
            <span>{c.name}</span>
            {checked && (isCorrect ? " âœ…" : " âŒ")}
          </button>
        );
      })}

      {checked && caseData.criteria.map((c, i) => {
        const userSaysMet = !!answers[i];
        if (userSaysMet === c.met) return null;
        return (
          <div key={`fb-${i}`} style={{
            padding: 12, borderRadius: 10, marginBottom: 8,
            background: "#FFFFFF", border: "1px solid #D0E0EA", boxShadow: "0 2px 8px #00000008",
            fontSize: 13, color: "#2C3E50", lineHeight: 1.5,
          }}>
            <strong style={{ color: "#FFE66D" }}>{c.name}:</strong>{" "}
            {c.met ? `SÃ lo cumple â€” ${c.explanation}` : `NO lo cumple â€” ${c.explanation}`}
          </div>
        );
      })}

      {!checked && (
        <button onClick={handleCheck} style={{
          marginTop: 12, width: "100%", padding: "14px",
          background: "linear-gradient(135deg, #E8A817, #D4960F)", color: "#FFFFFF",
          border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
        }}>
          Verificar âœ”ï¸
        </button>
      )}

      {checked && (
        <button onClick={handleNext} style={{
          marginTop: 12, width: "100%", padding: "14px",
          background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
          border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
        }}>
          {isLast ? "Completar ejercicio â†’" : "Siguiente anÃ¡lisis â†’"}
        </button>
      )}
    </div>
  );
};

// Clinical case simulation (Level 4)
const CaseSimulation = ({ caseData, onComplete }) => {
  const [stageIdx, setStageIdx] = useState(-1); // -1 = intro
  const [answered, setAnswered] = useState(false);
  const [selectedIdx, setSelectedIdx] = useState(null);
  const [optimalCount, setOptimalCount] = useState(0);
  const [history, setHistory] = useState([]);

  const stage = stageIdx >= 0 ? caseData.stages[stageIdx] : null;
  const isLastStage = stageIdx === caseData.stages.length - 1;

  const handleAnswer = (i) => {
    setSelectedIdx(i);
    setAnswered(true);
    const opt = stage.options[i];
    if (opt.isOptimal) setOptimalCount(c => c + 1);
    setHistory(h => [...h, { stage: stage.title, choice: opt.text, optimal: opt.isOptimal }]);
  };

  const handleNext = () => {
    if (isLastStage) { onComplete(optimalCount); return; }
    setStageIdx(i => i + 1);
    setAnswered(false);
    setSelectedIdx(null);
  };

  const renderRichText = (text) => {
    return text.split("\n").map((line, i) => {
      if (!line.trim()) return <br key={i} />;
      let processed = line.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#D4880F">$1</strong>');
      return <p key={i} style={{ margin: "6px 0", fontSize: 14, lineHeight: 1.6, color: "#2C3E50" }} dangerouslySetInnerHTML={{ __html: processed }} />;
    });
  };

  // Intro screen
  if (stageIdx === -1) {
    return (
      <div>
        <div style={{ background: "#EDF4FA", borderRadius: 16, padding: 20, border: "1px solid #8E44AD40", marginBottom: 16 }}>
          {renderRichText(caseData.intro)}
        </div>
        <button onClick={() => setStageIdx(0)} style={{
          width: "100%", padding: "16px",
          background: "linear-gradient(135deg, #8E44AD, #7D3C98)", color: "#FFFFFF",
          border: "none", borderRadius: 14, fontSize: 17, fontWeight: 700, cursor: "pointer",
        }}>
          Comenzar consulta ğŸ©º
        </button>
      </div>
    );
  }

  return (
    <div>
      <div style={{
        display: "flex", gap: 4, marginBottom: 16,
      }}>
        {caseData.stages.map((_, i) => (
          <div key={i} style={{
            flex: 1, height: 4, borderRadius: 2,
            background: i <= stageIdx ? "#8E44AD" : "#D0DDE6",
            transition: "background 0.5s",
          }} />
        ))}
      </div>

      <h4 style={{ fontSize: 17, fontWeight: 800, color: "#7D3C98", marginBottom: 8 }}>{stage.title}</h4>
      
      <div style={{ background: "#EDF4FA", borderRadius: 14, padding: 16, marginBottom: 16, border: "1px solid #D0E0EA" }}>
        {renderRichText(stage.description)}
      </div>

      <p style={{ fontSize: 15, fontWeight: 600, color: "#0d1b2a", marginBottom: 14 }}>{stage.question}</p>

      <div style={{ display: "flex", flexDirection: "column", gap: 10 }}>
        {stage.options.map((opt, i) => {
          const isSelected = selectedIdx === i;
          let bg = "linear-gradient(145deg, #F0F6FC, #E6F0F9)";
          let border = "1px solid #ffffff20";
          if (answered) {
            if (opt.isOptimal) { bg = "#D4F5E0"; border = "2px solid #4ECDC4"; }
            else if (isSelected) { bg = "#FDDEDE"; border = "2px solid #FF8A5C"; }
          }
          return (
            <button key={i} onClick={() => !answered && handleAnswer(i)} disabled={answered} style={{
              padding: "14px 16px", background: bg, border, borderRadius: 12,
              color: "#0d1b2a", fontSize: 14, textAlign: "left", cursor: answered ? "default" : "pointer",
              transition: "all 0.3s", lineHeight: 1.5, opacity: answered && !isSelected && !opt.isOptimal ? 0.5 : 1,
            }}>
              {opt.text}
              {answered && opt.isOptimal && " ğŸ¯"}
              {answered && isSelected && !opt.isOptimal && " ğŸ”¸"}
            </button>
          );
        })}
      </div>

      {answered && (
        <>
          <FeedbackBox
            text={stage.options[selectedIdx].feedback}
            isCorrect={stage.options[selectedIdx].isOptimal}
          />
          <button onClick={handleNext} style={{
            width: "100%", padding: "14px",
            background: `linear-gradient(135deg, ${isLastStage ? "#E8A817" : "#8E44AD"}, ${isLastStage ? "#D4960F" : "#7D3C98"})`,
            color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            {isLastStage ? "Finalizar consulta ğŸ" : "Siguiente etapa â†’"}
          </button>
        </>
      )}
    </div>
  );
};

// Summary card at level end
const LevelSummary = ({ level, principles, onNext }) => {
  const [visible, setVisible] = useState(false);
  useEffect(() => { setTimeout(() => setVisible(true), 200); }, []);

  return (
    <div style={{
      opacity: visible ? 1 : 0, transform: visible ? "scale(1)" : "scale(0.9)",
      transition: "all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1)",
      background: "linear-gradient(145deg, #D4F5E0, #C2EDCF)",
      borderRadius: 20, padding: 24, border: "2px solid #2EAF70", textAlign: "center",
    }}>
      <div style={{ fontSize: 48, marginBottom: 8 }}>ğŸ‰</div>
      <h3 style={{ fontSize: 22, fontWeight: 800, color: "#1A7A4A", marginBottom: 16 }}>
        Â¡Nivel {level} Completado!
      </h3>
      <div style={{ textAlign: "left", marginBottom: 20 }}>
        <p style={{ fontSize: 13, color: "#D4880F", fontWeight: 700, marginBottom: 10 }}>ğŸ“ Principios clave para llevar contigo:</p>
        {principles.map((p, i) => (
          <div key={i} style={{
            background: "#ffffff08", borderRadius: 10, padding: 12, marginBottom: 8,
            fontSize: 14, color: "#2C3E50", lineHeight: 1.5, border: "1px solid #D0E0EA",
          }}>
            {p}
          </div>
        ))}
      </div>
      <button onClick={onNext} style={{
        width: "100%", padding: "16px",
        background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
        border: "none", borderRadius: 14, fontSize: 17, fontWeight: 700, cursor: "pointer",
      }}>
        {level < 4 ? `Ir al Nivel ${level + 1} â†’` : "Ver resultados finales ğŸ†"}
      </button>
    </div>
  );
};

// ==================== MAIN APP ====================
function App() {
  const [screen, setScreen] = useState("home"); // home, level, summary, final
  const [currentLevel, setCurrentLevel] = useState(1);
  const [phase, setPhase] = useState("theory"); // theory, exercises
  const [theoryIdx, setTheoryIdx] = useState(0);
  const [exerciseIdx, setExerciseIdx] = useState(0);
  const [completedLevels, setCompletedLevels] = useState([]);
  const [showSummary, setShowSummary] = useState(false);
  const containerRef = useRef(null);

  const scrollToTop = () => {
    if (containerRef.current) containerRef.current.scrollTo({ top: 0, behavior: "smooth" });
  };

  const skills = [
    { name: "Reconocer TRAPs", emoji: "ğŸª¤", color: "#FF6B6B", unlocked: completedLevels.includes(1), progress: completedLevels.includes(1) ? 100 : currentLevel === 1 ? (phase === "exercises" ? 50 + (exerciseIdx / 4) * 50 : (theoryIdx / 3) * 50) : 0 },
    { name: "Distinguir TRAP vs TRAC", emoji: "ğŸ”", color: "#4ECDC4", unlocked: completedLevels.includes(2), progress: completedLevels.includes(2) ? 100 : currentLevel === 2 ? (phase === "exercises" ? 50 + (exerciseIdx / 3) * 50 : (theoryIdx / 3) * 50) : 0 },
    { name: "Construir afrontamientos", emoji: "ğŸ”§", color: "#FFE66D", unlocked: completedLevels.includes(3), progress: completedLevels.includes(3) ? 100 : currentLevel === 3 ? (phase === "exercises" ? 50 + (exerciseIdx / 3) * 50 : (theoryIdx / 3) * 50) : 0 },
    { name: "AplicaciÃ³n clÃ­nica", emoji: "ğŸ¯", color: "#A855F7", unlocked: completedLevels.includes(4), progress: completedLevels.includes(4) ? 100 : currentLevel === 4 ? (phase === "exercises" ? 70 : 30) : 0 },
  ];

  const getTheory = () => {
    if (currentLevel === 1) return L1_THEORY;
    if (currentLevel === 2) return L2_THEORY;
    if (currentLevel === 3) return L3_THEORY;
    return [];
  };

  const getExercises = () => {
    if (currentLevel === 1) return L1_EXERCISES;
    if (currentLevel === 2) return L2_EXERCISES;
    if (currentLevel === 3) return L3_EXERCISES;
    return [];
  };

  const summaryPrinciples = {
    1: [
      "ğŸª¤ TRAP = Trigger â†’ Response â†’ Avoidance Pattern. La evitaciÃ³n alivia a corto plazo pero mantiene la depresiÃ³n.",
      "ğŸ” No importa QUÃ‰ haces, importa PARA QUÃ‰ lo haces. La misma conducta puede ser afrontamiento o evitaciÃ³n segÃºn su funciÃ³n.",
      "âš¡ La evitaciÃ³n es lÃ³gica y comprensible, pero es una trampa. Reconocerla es el primer paso para salir.",
    ],
    2: [
      "ğŸ’ª TRAC = Trigger â†’ Response â†’ Alternative Coping. La salida de la trampa es actuar diferente, no sentir diferente.",
      "ğŸ­ La evitaciÃ³n mÃ¡s peligrosa es la que se disfraza de acciÃ³n: hacer lo mÃ­nimo, planificar sin ejecutar, investigar sin actuar.",
      "ğŸ§­ Pregunta clave: 'Â¿Esto me ACERCA a lo que valoro o me ALEJA del malestar?' Si solo te aleja del malestar, probablemente es evitaciÃ³n.",
    ],
    3: [
      "âœ… Un buen afrontamiento alternativo: rompe el patrÃ³n, se alinea con valores, contacta con reforzadores, y es especÃ­fico y factible.",
      "ğŸ“ Empieza PEQUEÃ‘O. Un paso imperfecto ejecutado vale mÃ¡s que un plan perfecto admirado.",
      "ğŸ”¬ Analiza la FUNCIÃ“N, no la FORMA. Ir al parque con audÃ­fonos puede ser evitaciÃ³n; enviar 2 CVs imperfectos puede ser afrontamiento.",
    ],
    4: [
      "ğŸ©º En la prÃ¡ctica real, los TRAPs son mÃºltiples y simultÃ¡neos. Elige estratÃ©gicamente cuÃ¡l abordar primero segÃºn el impacto potencial.",
      "ğŸ”„ Las recaÃ­das no son fracasos, son informaciÃ³n. Cada 'intento fallido' revela nuevos triggers y patrones.",
      "ğŸ La prevenciÃ³n de recaÃ­das no es 'nunca mÃ¡s te sentirÃ¡s mal'. Es: cuando la trampa aparezca, tienes herramientas para reconocerla y elegir diferente.",
    ],
  };

  const startLevel = (level) => {
    setCurrentLevel(level);
    setPhase("theory");
    setTheoryIdx(0);
    setExerciseIdx(0);
    setShowSummary(false);
    setScreen("level");
    scrollToTop();
  };

  const handleTheoryNext = () => {
    const theory = getTheory();
    if (theoryIdx < theory.length - 1) {
      setTheoryIdx(i => i + 1);
      scrollToTop();
    } else {
      setPhase("exercises");
      setExerciseIdx(0);
      scrollToTop();
    }
  };

  const handleExerciseComplete = () => {
    const exercises = getExercises();
    if (exerciseIdx < exercises.length - 1) {
      setExerciseIdx(i => i + 1);
      scrollToTop();
    } else {
      setShowSummary(true);
      scrollToTop();
    }
  };

  const handleLevelComplete = () => {
    setCompletedLevels(prev => [...new Set([...prev, currentLevel])]);
    if (currentLevel < 4) {
      startLevel(currentLevel + 1);
    } else {
      setScreen("final");
      scrollToTop();
    }
  };

  const renderExercise = (ex, idx) => {
    const wrapStyle = {
      background: "linear-gradient(145deg, #FFFFFF, #F5FAFF)",
      borderRadius: 20, padding: 20, marginBottom: 16,
      border: ex.type === "expert_trap" ? "2px solid #D4880F30" : "1px solid #C0D8E8",
      boxShadow: "0 4px 20px #00000010",
    };

    if (ex.type === "identify_component") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{ fontSize: 11, color: "#C0392B", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
            ğŸ‹ï¸ Ejercicio {idx + 1}
          </div>
          <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 12, lineHeight: 1.5 }}>{ex.instruction}</p>
          <div style={{
            background: "#EDF4FA", borderRadius: 14, padding: 14, marginBottom: 16,
            border: "1px solid #D0E0EA", fontSize: 14, color: "#2C3E50", lineHeight: 1.7,
          }}>
            {ex.scenario}
          </div>
          <IdentifyComponentExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    if (ex.type === "classify_full") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{ fontSize: 11, color: "#C0392B", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
            ğŸ‹ï¸ Ejercicio {idx + 1}
          </div>
          <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 12, lineHeight: 1.5 }}>{ex.instruction}</p>
          <ClassifyExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    if (ex.type === "expert_trap") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{
            fontSize: 12, fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8,
            background: "linear-gradient(90deg, #D4880F, #C0392B)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent",
          }}>
            âš¡ Trampa del Experto
          </div>
          <p style={{ fontSize: 13, color: "#C0392B", marginBottom: 12, lineHeight: 1.5, whiteSpace: "pre-line" }}>{ex.instruction}</p>
          <div style={{
            background: "#EDF4FA", borderRadius: 14, padding: 14, marginBottom: 16,
            border: "1px solid #D4880F30", fontSize: 14, color: "#2C3E50", lineHeight: 1.7,
          }}>
            {ex.scenario}
          </div>
          <ExpertTrapExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    if (ex.type === "trap_or_trac") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{ fontSize: 11, color: "#1A7A4A", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
            ğŸ‹ï¸ Ejercicio {idx + 1}
          </div>
          <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 12, lineHeight: 1.5 }}>{ex.instruction}</p>
          <TrapOrTracExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    if (ex.type === "unmask_avoidance") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{ fontSize: 11, color: "#C0392B", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
            ğŸ‹ï¸ Ejercicio {idx + 1}
          </div>
          <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 12, lineHeight: 1.5, whiteSpace: "pre-line" }}>{ex.instruction}</p>
          <UnmaskExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    if (ex.type === "choose_best_coping") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{ fontSize: 11, color: "#FFE66D", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
            ğŸ‹ï¸ Ejercicio {idx + 1}
          </div>
          <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 12, lineHeight: 1.5 }}>{ex.instruction}</p>
          <ChooseCopingExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    if (ex.type === "justify_criteria") {
      return (
        <div key={idx} style={wrapStyle}>
          <div style={{ fontSize: 11, color: "#1A7A4A", fontWeight: 700, letterSpacing: 2, textTransform: "uppercase", marginBottom: 8 }}>
            ğŸ‹ï¸ Ejercicio {idx + 1}
          </div>
          <p style={{ fontSize: 13, color: "#5A7A8A", marginBottom: 12, lineHeight: 1.5 }}>{ex.instruction}</p>
          <CriteriaExercise exercise={ex} onComplete={handleExerciseComplete} />
        </div>
      );
    }
    return null;
  };

  // HOME SCREEN
  if (screen === "home") {
    return (
      <div ref={containerRef} style={{
        minHeight: "100vh", background: "linear-gradient(180deg, #D0E8F7 0%, #E3F0FA 50%, #C8E1F2 100%)",
        color: "#0d1b2a", fontFamily: "'Segoe UI', system-ui, sans-serif",
        overflowY: "auto", position: "relative",
      }}>
        <Particles />
        <div style={{ position: "relative", zIndex: 1, padding: "20px 16px", maxWidth: 480, margin: "0 auto" }}>
          {/* Header */}
          <div style={{ textAlign: "center", paddingTop: 20, paddingBottom: 24 }}>
            <div style={{
              fontSize: 56, marginBottom: 8,
              animation: "pulse 2s ease-in-out infinite",
            }}>ğŸª¤</div>
            <h1 style={{
              fontSize: 32, fontWeight: 900, lineHeight: 1.2, marginBottom: 8,
              background: "linear-gradient(135deg, #E74C3C, #E8A817, #2EAF70)",
              WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent",
            }}>
              TRAP â†’ TRAC
            </h1>
            <p style={{ fontSize: 15, color: "#5A7A8A", lineHeight: 1.5, maxWidth: 320, margin: "0 auto" }}>
              Aprende a reconocer las trampas de la depresiÃ³n y construir salidas efectivas
            </p>
            <div style={{
              marginTop: 12, display: "inline-block",
              background: "#FFFFFF", borderRadius: 20, padding: "6px 14px",
              fontSize: 12, color: "#1A7A4A", border: "1px solid #2EAF7040", boxShadow: "0 2px 8px #00000008", fontWeight: 600,
            }}>
              Basado en ActivaciÃ³n Conductual Â· Martell, Dimidjian & Herman-Dunn
            </div>
          </div>

          {/* Skill thermometer */}
          <SkillThermometer skills={skills} />

          {/* Level cards */}
          {LEVELS_META.map((level, i) => {
            const isUnlocked = i === 0 || completedLevels.includes(i);
            const isCompleted = completedLevels.includes(level.id);
            return (
              <button
                key={level.id}
                onClick={() => isUnlocked && startLevel(level.id)}
                disabled={!isUnlocked}
                style={{
                  display: "flex", alignItems: "center", gap: 16, width: "100%",
                  padding: "18px 16px", marginBottom: 12,
                  background: isCompleted
                    ? "linear-gradient(145deg, #D4F5E0, #C2EDCF)"
                    : isUnlocked
                      ? "linear-gradient(145deg, #FFFFFF, #F5FAFF)"
                      : "#E0E8EF",
                  border: `2px solid ${isCompleted ? "#2EAF70" : isUnlocked ? level.color + "60" : "#C0D0DA"}`,
                  borderRadius: 16,
                  cursor: isUnlocked ? "pointer" : "not-allowed",
                  opacity: isUnlocked ? 1 : 0.5,
                  textAlign: "left",
                  transition: "all 0.3s",
                }}
              >
                <div style={{
                  width: 50, height: 50, borderRadius: 14,
                  background: `${level.color}25`,
                  display: "flex", alignItems: "center", justifyContent: "center",
                  fontSize: 28, flexShrink: 0,
                }}>
                  {isCompleted ? "âœ…" : isUnlocked ? level.emoji : "ğŸ”’"}
                </div>
                <div>
                  <div style={{ fontSize: 11, color: level.color, fontWeight: 700, letterSpacing: 1 }}>
                    NIVEL {level.id}
                  </div>
                  <div style={{ fontSize: 16, fontWeight: 700, color: "#0d1b2a", marginTop: 2 }}>
                    {level.title}
                  </div>
                  <div style={{ fontSize: 12, color: "#5A7A8A", marginTop: 2, lineHeight: 1.4 }}>
                    {level.desc}
                  </div>
                </div>
              </button>
            );
          })}

          <div style={{ textAlign: "center", padding: "24px 0 40px", fontSize: 12, color: "#8A9DAB" }}>
            Creado con ğŸ’œ para tu crecimiento profesional
            <br />@leo.eyzaguirre
          </div>
        </div>

        <style>{`
          @keyframes floatParticle {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
            25% { transform: translate(20px, -30px) scale(1.2); opacity: 0.6; }
            50% { transform: translate(-10px, -60px) scale(0.8); opacity: 0.4; }
            75% { transform: translate(30px, -30px) scale(1.1); opacity: 0.5; }
          }
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
          }
          @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
          }
          * { box-sizing: border-box; margin: 0; padding: 0; }
          button { font-family: inherit; }
          textarea { font-family: inherit; }
        `}</style>
      </div>
    );
  }

  // LEVEL SCREEN
  if (screen === "level") {
    const theory = getTheory();
    const exercises = getExercises();
    const levelMeta = LEVELS_META[currentLevel - 1];

    return (
      <div ref={containerRef} style={{
        minHeight: "100vh", background: "linear-gradient(180deg, #D0E8F7 0%, #E3F0FA 50%, #C8E1F2 100%)",
        color: "#0d1b2a", fontFamily: "'Segoe UI', system-ui, sans-serif",
        overflowY: "auto", position: "relative",
      }}>
        <Particles />
        <div style={{ position: "relative", zIndex: 1, padding: "16px", maxWidth: 480, margin: "0 auto" }}>
          {/* Top bar */}
          <div style={{ display: "flex", alignItems: "center", gap: 12, marginBottom: 20 }}>
            <button onClick={() => setScreen("home")} style={{
              background: "#ffffff10", border: "none", borderRadius: 10, padding: "8px 12px",
              color: "#0d1b2a", fontSize: 14, cursor: "pointer",
            }}>
              â† Inicio
            </button>
            <div style={{ flex: 1 }}>
              <div style={{ fontSize: 11, color: levelMeta.color, fontWeight: 700, letterSpacing: 1 }}>
                NIVEL {currentLevel} {levelMeta.emoji}
              </div>
              <div style={{ fontSize: 15, fontWeight: 700, color: "#0d1b2a" }}>{levelMeta.title}</div>
            </div>
          </div>

          {/* Phase indicator */}
          <div style={{ display: "flex", gap: 4, marginBottom: 20 }}>
            {theory.map((_, i) => (
              <div key={`t${i}`} style={{
                flex: 1, height: 4, borderRadius: 2,
                background: phase === "theory" && i <= theoryIdx ? levelMeta.color : phase === "exercises" ? levelMeta.color : "#333",
                transition: "background 0.5s",
              }} />
            ))}
            <div style={{ width: 2, background: "#ffffff30" }} />
            {(currentLevel < 4 ? exercises : [1]).map((_, i) => (
              <div key={`e${i}`} style={{
                flex: 1, height: 4, borderRadius: 2,
                background: phase === "exercises" && i <= exerciseIdx ? "#4ECDC4" : "#333",
                transition: "background 0.5s",
              }} />
            ))}
          </div>

          {/* THEORY */}
          {phase === "theory" && !showSummary && currentLevel < 4 && (
            <TheoryCard
              section={theory[theoryIdx]}
              index={theoryIdx}
              onNext={handleTheoryNext}
              isLast={theoryIdx === theory.length - 1}
            />
          )}

          {/* LEVEL 4 INTRO */}
          {phase === "theory" && currentLevel === 4 && !showSummary && (
            <div style={{
              background: "linear-gradient(145deg, #FFFFFF, #F5FAFF)",
              borderRadius: 20, padding: 24, marginBottom: 16,
              border: "1px solid #8E44AD40",
            }}>
              <h3 style={{ fontSize: 22, fontWeight: 800, color: "#A855F7", marginBottom: 16 }}>
                {L4_INTRO.title}
              </h3>
              <div style={{ color: "#2C3E50", fontSize: 15, lineHeight: 1.7 }}>
                {L4_INTRO.content.split("\n").map((line, i) => {
                  if (!line.trim()) return <br key={i} />;
                  let p = line.replace(/\*\*(.*?)\*\*/g, '<strong style="color:#D4880F">$1</strong>');
                  return <p key={i} style={{ margin: "6px 0" }} dangerouslySetInnerHTML={{ __html: p }} />;
                })}
              </div>
              <button onClick={() => { setPhase("exercises"); scrollToTop(); }} style={{
                marginTop: 20, width: "100%", padding: "16px",
                background: "linear-gradient(135deg, #8E44AD, #7D3C98)", color: "#FFFFFF",
                border: "none", borderRadius: 14, fontSize: 17, fontWeight: 700, cursor: "pointer",
              }}>
                Comenzar la consulta simulada ğŸ©º
              </button>
            </div>
          )}

          {/* EXERCISES */}
          {phase === "exercises" && !showSummary && currentLevel < 4 && (
            renderExercise(exercises[exerciseIdx], exerciseIdx)
          )}

          {/* LEVEL 4 CASE */}
          {phase === "exercises" && !showSummary && currentLevel === 4 && (
            <div style={{
              background: "linear-gradient(145deg, #FFFFFF, #F5FAFF)",
              borderRadius: 20, padding: 20,
              border: "1px solid #8E44AD40",
            }}>
              <CaseSimulation caseData={L4_CASE} onComplete={() => setShowSummary(true)} />
            </div>
          )}

          {/* SUMMARY */}
          {showSummary && (
            <LevelSummary
              level={currentLevel}
              principles={summaryPrinciples[currentLevel]}
              onNext={handleLevelComplete}
            />
          )}
        </div>

        <style>{`
          @keyframes floatParticle {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
            25% { transform: translate(20px, -30px) scale(1.2); opacity: 0.6; }
            50% { transform: translate(-10px, -60px) scale(0.8); opacity: 0.4; }
            75% { transform: translate(30px, -30px) scale(1.1); opacity: 0.5; }
          }
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
          }
          @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
          }
          * { box-sizing: border-box; margin: 0; padding: 0; }
          button { font-family: inherit; }
          textarea { font-family: inherit; }
        `}</style>
      </div>
    );
  }

  // FINAL SCREEN
  if (screen === "final") {
    return (
      <div ref={containerRef} style={{
        minHeight: "100vh", background: "linear-gradient(180deg, #D0E8F7 0%, #E3F0FA 50%, #C8E1F2 100%)",
        color: "#0d1b2a", fontFamily: "'Segoe UI', system-ui, sans-serif",
        overflowY: "auto", position: "relative",
      }}>
        <Particles />
        <div style={{ position: "relative", zIndex: 1, padding: "40px 16px 20px", maxWidth: 480, margin: "0 auto", textAlign: "center" }}>
          <div style={{ fontSize: 72, marginBottom: 16, animation: "pulse 2s ease-in-out infinite" }}>ğŸ†</div>
          <h1 style={{
            fontSize: 28, fontWeight: 900, lineHeight: 1.2, marginBottom: 12,
            background: "linear-gradient(135deg, #E8A817, #E74C3C, #2EAF70, #8E44AD)",
            WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent",
          }}>
            Â¡Completaste todos los niveles!
          </h1>
          <p style={{ fontSize: 15, color: "#2C3E50", lineHeight: 1.6, marginBottom: 24, maxWidth: 360, margin: "0 auto 24px" }}>
            Ahora tienes las herramientas para reconocer TRAPs, distinguir evitaciÃ³n de afrontamiento, construir salidas efectivas y aplicar todo en contextos reales.
          </p>
          
          <SkillThermometer skills={skills} />

          <div style={{
            background: "#FFFFFF", borderRadius: 16, padding: 20, marginBottom: 24,
            border: "1px solid #C0D8E8", textAlign: "left",
          }}>
            <p style={{ fontSize: 14, color: "#D4880F", fontWeight: 700, marginBottom: 12 }}>
              ğŸ§  Recuerda siempre:
            </p>
            <p style={{ fontSize: 14, color: "#2C3E50", lineHeight: 1.7 }}>
              La activaciÃ³n conductual no pide que te sientas bien para actuar. Pide que actÃºes para tener la oportunidad de sentirte bien. Los TRAPs aparecerÃ¡n siempre â€” lo que cambia es tu habilidad para reconocerlos y elegir un TRAC.
            </p>
          </div>

          <button onClick={() => { setScreen("home"); setCompletedLevels([1, 2, 3, 4]); }} style={{
            width: "100%", padding: "16px",
            background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
            border: "none", borderRadius: 14, fontSize: 17, fontWeight: 700, cursor: "pointer",
          }}>
            Volver al inicio ğŸ 
          </button>

          {/* Feedback Form */}
          <FeedbackForm />

          <div style={{ textAlign: "center", padding: "24px 0", fontSize: 12, color: "#8A9DAB" }}>
            Creado con ğŸ’œ Â· @leo.eyzaguirre
          </div>
        </div>
        <style>{`
          @keyframes floatParticle {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
            25% { transform: translate(20px, -30px) scale(1.2); opacity: 0.6; }
            50% { transform: translate(-10px, -60px) scale(0.8); opacity: 0.4; }
            75% { transform: translate(30px, -30px) scale(1.1); opacity: 0.5; }
          }
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
          }
          @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
          }
          * { box-sizing: border-box; margin: 0; padding: 0; }
          button { font-family: inherit; }
          textarea { font-family: inherit; }
        `}</style>
      </div>
    );
  }

  return null;
}

// Feedback form with Formspree
function FeedbackForm() {
  const [isOpen, setIsOpen] = useState(false);
  const [message, setMessage] = useState("");
  const [type, setType] = useState(null);
  const [status, setStatus] = useState("idle"); // idle, sending, sent, error

  const FORMSPREE_ID = "xbdadlnz"; // â† Reemplaza con tu ID de Formspree

  const handleSubmit = async () => {
    if (!message.trim()) return;
    setStatus("sending");
    try {
      const res = await fetch(`https://formspree.io/f/${FORMSPREE_ID}`, {
        method: "POST",
        headers: { "Content-Type": "application/json", "Accept": "application/json" },
        body: JSON.stringify({
          tipo: type === "mejora" ? "ğŸ’¡ Idea de mejora" : type === "ejercicio" ? "ğŸ‹ï¸ Mejora de ejercicio" : "ğŸ’¬ Comentario general",
          mensaje: message,
          fecha: new Date().toLocaleString("es-BO"),
        }),
      });
      if (res.ok) {
        setStatus("sent");
        setMessage("");
        setType(null);
      } else {
        setStatus("error");
      }
    } catch {
      setStatus("error");
    }
  };

  if (!isOpen) {
    return (
      <button
        onClick={() => setIsOpen(true)}
        style={{
          width: "100%", marginTop: 20, padding: "14px 16px",
          background: "transparent", border: "2px dashed #8E44AD60",
          borderRadius: 14, cursor: "pointer", transition: "all 0.3s",
          display: "flex", alignItems: "center", justifyContent: "center", gap: 8,
        }}
      >
        <span style={{ fontSize: 20 }}>ğŸ’¬</span>
        <span style={{ fontSize: 14, color: "#5A7A8A", fontWeight: 600 }}>
          Â¿Tienes ideas para mejorar esta herramienta? (opcional)
        </span>
      </button>
    );
  }

  if (status === "sent") {
    return (
      <div style={{
        marginTop: 20, padding: 20, borderRadius: 16,
        background: "linear-gradient(145deg, #D4F5E0, #C2EDCF)",
        border: "2px solid #2EAF70", textAlign: "center",
        animation: "fadeSlideIn 0.4s ease-out",
      }}>
        <div style={{ fontSize: 40, marginBottom: 8 }}>âœ…</div>
        <p style={{ fontSize: 16, fontWeight: 700, color: "#1A7A4A", marginBottom: 4 }}>
          Â¡Gracias por tu feedback!
        </p>
        <p style={{ fontSize: 13, color: "#2C6E49" }}>
          Tu mensaje fue enviado. Me ayuda mucho a mejorar esta herramienta. ğŸ™
        </p>
      </div>
    );
  }

  return (
    <div style={{
      marginTop: 20, padding: 20, borderRadius: 16,
      background: "#FFFFFF", border: "1px solid #C0D8E8",
      boxShadow: "0 4px 16px #00000008", textAlign: "left",
      animation: "fadeSlideIn 0.4s ease-out",
    }}>
      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 14 }}>
        <div>
          <p style={{ fontSize: 16, fontWeight: 700, color: "#0d1b2a" }}>ğŸ’¬ Tu feedback</p>
          <p style={{ fontSize: 12, color: "#5A7A8A", marginTop: 2 }}>Opcional Â· Solo lo veo yo</p>
        </div>
        <button
          onClick={() => setIsOpen(false)}
          style={{
            background: "#EDF4FA", border: "none", borderRadius: 8,
            width: 32, height: 32, cursor: "pointer", fontSize: 16,
            color: "#5A7A8A", display: "flex", alignItems: "center", justifyContent: "center",
          }}
        >âœ•</button>
      </div>

      {/* Type selector */}
      <p style={{ fontSize: 12, color: "#5A7A8A", fontWeight: 600, marginBottom: 8 }}>
        Â¿Sobre quÃ© quieres comentar?
      </p>
      <div style={{ display: "flex", gap: 8, marginBottom: 16 }}>
        {[
          { id: "mejora", emoji: "ğŸ’¡", label: "Idea de mejora" },
          { id: "ejercicio", emoji: "ğŸ‹ï¸", label: "Ejercicios" },
          { id: "general", emoji: "ğŸ’¬", label: "General" },
        ].map(opt => (
          <button
            key={opt.id}
            onClick={() => setType(opt.id)}
            style={{
              flex: 1, padding: "10px 6px", borderRadius: 10,
              background: type === opt.id ? "#E0EFFF" : "#F5FAFF",
              border: `2px solid ${type === opt.id ? "#3498DB" : "#D0E0EA"}`,
              cursor: "pointer", transition: "all 0.2s", textAlign: "center",
            }}
          >
            <div style={{ fontSize: 18 }}>{opt.emoji}</div>
            <div style={{ fontSize: 11, fontWeight: 600, color: type === opt.id ? "#2471A3" : "#5A7A8A", marginTop: 2 }}>
              {opt.label}
            </div>
          </button>
        ))}
      </div>

      {/* Text area */}
      <textarea
        value={message}
        onChange={(e) => setMessage(e.target.value)}
        placeholder="Escribe tu idea, sugerencia o comentario aquÃ­..."
        rows={4}
        style={{
          width: "100%", padding: "12px 14px", borderRadius: 12,
          border: "2px solid #D0E0EA", background: "#F5FAFF",
          fontSize: 14, color: "#0d1b2a", resize: "vertical",
          fontFamily: "inherit", lineHeight: 1.5, outline: "none",
          transition: "border-color 0.3s",
        }}
        onFocus={(e) => e.target.style.borderColor = "#3498DB"}
        onBlur={(e) => e.target.style.borderColor = "#D0E0EA"}
      />

      {/* Submit */}
      <button
        onClick={handleSubmit}
        disabled={!message.trim() || !type || status === "sending"}
        style={{
          marginTop: 12, width: "100%", padding: "14px",
          background: message.trim() && type
            ? "linear-gradient(135deg, #8E44AD, #7D3C98)"
            : "#D0DDE6",
          color: message.trim() && type ? "#FFFFFF" : "#8A9DAB",
          border: "none", borderRadius: 12, fontSize: 15, fontWeight: 700,
          cursor: message.trim() && type ? "pointer" : "not-allowed",
          transition: "all 0.3s",
          opacity: status === "sending" ? 0.7 : 1,
        }}
      >
        {status === "sending" ? "Enviando... â³" : status === "error" ? "Error â€” Reintentar ğŸ”„" : "Enviar feedback ğŸ“©"}
      </button>

      {status === "error" && (
        <p style={{ fontSize: 12, color: "#C0392B", marginTop: 8, textAlign: "center" }}>
          No se pudo enviar. Verifica tu conexiÃ³n o que el ID de Formspree sea correcto.
        </p>
      )}
    </div>
  );
}

// Identify component sub-exercise
function IdentifyComponentExercise({ exercise, onComplete }) {
  const [currentQ, setCurrentQ] = useState(0);
  const [answered, setAnswered] = useState(false);
  const [selectedIdx, setSelectedIdx] = useState(null);
  const [correctCount, setCorrectCount] = useState(0);
  const q = exercise.questions[currentQ];
  const isLast = currentQ === exercise.questions.length - 1;

  const handleAnswer = (i) => {
    setSelectedIdx(i);
    setAnswered(true);
    if (i === q.correct) setCorrectCount(c => c + 1);
  };

  const handleNext = () => {
    if (isLast) { onComplete(); return; }
    setCurrentQ(i => i + 1);
    setAnswered(false);
    setSelectedIdx(null);
  };

  return (
    <div>
      <MCExercise
        question={q}
        options={q.options}
        onAnswer={handleAnswer}
        answered={answered}
        selectedIdx={selectedIdx}
      />
      {answered && (
        <>
          <FeedbackBox
            text={selectedIdx === q.correct ? q.feedback.correct : q.feedback.wrong}
            isCorrect={selectedIdx === q.correct}
          />
          <button onClick={handleNext} style={{
            width: "100%", padding: "14px",
            background: "linear-gradient(135deg, #2EAF70, #27A05F)", color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            {isLast ? "Completar ejercicio â†’" : "Siguiente pregunta â†’"}
          </button>
        </>
      )}
    </div>
  );
}

// Expert trap sub-exercise
function ExpertTrapExercise({ exercise, onComplete }) {
  const [answered, setAnswered] = useState(false);
  const [selectedIdx, setSelectedIdx] = useState(null);

  const handleAnswer = (i) => {
    setSelectedIdx(i);
    setAnswered(true);
  };

  const isCorrect = answered && exercise.options[selectedIdx].isCorrect;

  return (
    <div>
      <MCExercise
        question={exercise.question}
        options={exercise.options}
        onAnswer={handleAnswer}
        answered={answered}
        selectedIdx={selectedIdx}
      />
      {answered && (
        <>
          <FeedbackBox
            text={isCorrect ? exercise.feedback.correct : exercise.feedback.wrong}
            isCorrect={isCorrect}
          />
          <button onClick={onComplete} style={{
            width: "100%", padding: "14px",
            background: "linear-gradient(135deg, #E8A817, #D4960F)", color: "#FFFFFF",
            border: "none", borderRadius: 12, fontSize: 16, fontWeight: 700, cursor: "pointer",
          }}>
            Continuar â†’
          </button>
        </>
      )}
    </div>
  );
}


const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(React.createElement(App));
  </script>
</body>
</html>
